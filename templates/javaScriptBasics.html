<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="stylesheet" href="../styles/css/reset.css" />
    <link rel="stylesheet" href="../styles/css/grids.css" />
    <link rel="stylesheet" href="../styles/css/general.css" />
    <link rel="stylesheet" href="../styles/css/generalMenu.css" />
    <link rel="stylesheet" href="../styles/css/javaScriptModel.css" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>

  <body>
    <!-- main -->
    <main class="main">
      <article class="article">
        <!-- тег script -->
        <section id="teg-script" class="form">
          <div class="form__bloc-info">
            <h1 class="form__heading">
              <a
                target="_blank"
                rel="noopener"
                href="https://learn.javascript.ru/hello-world"
                class="form__link"
              >
                Подключение JavaScript-кода, тег: «script»</a
              >
            </h1>
            <div class="form__bloc-hidden">
              <p class="form__description">
                Программы на JavaScript могут быть вставлены в любое место
                HTML-документа с помощью тега script.
              </p>
              <p class="form__syntax">
                &lt;script src="адрес_файла"&gt;&lt;/script&gt;
              </p>
              <p class="form__description">
                Подключают скрипт обычно в самом конце страницы, перед
                закрывающим тегом &lt;/body&gt;.
              </p>
              <p class="form__description">
                Если много JavaScript-кода, можно поместить его в отдельный
                файл. Файл скрипта можно подключить к HTML с помощью атрибута
                src. Для подключения нескольких скриптов используется несколько
                тегов.
              </p>
              <p class="form__syntax">
                &lt;script src="/js/script1.js"&gt;&lt;/script&gt; <br />
                &lt;script src="/js/script2.js"&gt;&lt;/script&gt;
              </p>
              <p class="form__description">
                Как правило, только простейшие скрипты помещаются в HTML. Более
                сложные выделяются в отдельные файлы.
              </p>
              <p class="form__description">
                <b
                  >Если атрибут src установлен, содержимое тега &lt;script&gt;
                  будет игнорироваться.</b
                >
                В одном теге &lt;script&gt; нельзя использовать одновременно
                атрибут src и код внутри. Нижеприведённый пример не работает:
              </p>
              <p class="form__syntax">
                &lt;script src="file.js"&gt; <br />
                alert(1); // содержимое игнорируется, так как есть атрибут src
                <br />
                &lt;/script&gt;
              </p>
              <p class="form__description">
                Тег &lt;script&gt; имеет несколько атрибутов, которые редко
                используются, но всё ещё могут встретиться в старом коде:
                <b>type="text/javascript"</b> и <b>language=</b>.
              </p>
              <p class="form__description">
                На текущий момент этого больше не требуется.
              </p>
              <p class="form__description"></p>
            </div>
          </div>
          <p class="form__subheading">
            <a
              target="_blank"
              rel="noopener"
              href="https://learn.javascript.ru/hello-world#tasks"
              class="form__link-tasks"
            >
              Задачи "тег script"</a
            >
          </p>
        </section>
        <!-- тег script -->

        <!-- Переменная -->
        <section id="peremennay" class="form">
          <div class="form__bloc-info">
            <h1 class="form__heading">
              <a
                target="_blank"
                rel="noopener"
                href="https://learn.javascript.ru/variables"
                class="form__link"
              >
                Переменная
              </a>
            </h1>
            <div class="form__bloc-hidden">
              <p class="form__description">
                Мы можем использовать переменные для хранения товаров,
                посетителей и других данных.
              </p>
              <h2 class="form__subheading">
                <a
                  target="_blank"
                  rel="noopener"
                  href="https://learn.javascript.ru/variables#variable-naming"
                  class="form__link"
                >
                  Имена переменных</a
                >
              </h2>
              <p class="form__description">
                В JavaScript есть ограничения и правила, касающиеся имён
                переменных:
              </p>

              <p class="form__description">
                1. Имя переменной должно содержать только буквы, цифры или
                символы $ и _.
              </p>

              <p class="form__description">
                2. Первый символ не должен быть цифрой.
              </p>

              <p class="form__description">
                3. <b>Регистр имеет значение. </b> Переменные с именами apple и
                AppLE – это две разные переменные.
              </p>

              <p class="form__description">
                4. Переменным удобно давать имена в соответствие с тем, что они
                содержат. Например, переменная price (в переводе цена) может
                содержать цену за что-либо, то есть число. Переменная name (имя)
                соответственно содержит имя, переменная fruits (фрукт) – это
                названия фруктов.
              </p>

              <p class="form__description">
                5. В названии переменной можно сочетать несколько слов.
                Например, price_fruits, что означает цена за фрукты. Это удобно.
                Не будет путаницы с переменными, когда их количество возрастёт.
              </p>

              <p class="form__description">
                6. Использование транслита (передача текста с помощью чужого
                алфавита) поможет тем, у кого есть проблемы с английским языком.
                То есть переменную price_fruits можно назвать cena_frukt (цена
                фрукт).
              </p>

              <p class="form__description">
                7. Если в названии переменной следуют друг за другом два или три
                слова, то каждое следующее слово принято писать с заглавной
                буквы: cenaAuto или nameCityCountry.
              </p>

              <p class="form__subheading">Зарезервированные имена</p>

              <p class="form__description">
                Существует
                <a
                  target="_blank"
                  rel="noopener"
                  href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Lexical_grammar#%D0%B7%D0%B0%D1%80%D0%B5%D0%B7%D0%B5%D1%80%D0%B2%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D0%B5_%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%B2%D1%8B%D0%B5_%D1%81%D0%BB%D0%BE%D0%B2%D0%B0_%D0%B2_ecmascript_2015"
                  class="form__link"
                >
                  список зарезервированных слов</a
                >

                , которые нельзя использовать в качестве имён переменных, потому
                что они используются самим языком.
              </p>

              <p class="form__subheading">
                <a
                  target="_blank"
                  rel="noopener"
                  href="https://learn.javascript.ru/variables#konstanty"
                  class="form__link"
                >
                  Константы</a
                >
              </p>
              <p class="form__description">
                Чтобы объявить константную, то есть, неизменяемую переменную,
                используйте const вместо let:
              </p>

              <p class="form__syntax">const myBirthday = '18.04.1982';</p>

              <p class="form__description">
                Переменные, объявленные с помощью const, называются
                «константами». Их нельзя изменить. Попытка сделать это приведёт
                к ошибке:
              </p>

              <p class="form__description">
                Если программист уверен, что переменная никогда не будет
                меняться, он может гарантировать это и наглядно донести до
                каждого, объявив её через const.
              </p>

              <p class="form__subheading">
                <a
                  target="_blank"
                  rel="noopener"
                  href="https://learn.javascript.ru/variables#konstanty-v-verhnem-registre"
                  class="form__link"
                >
                  Константы в верхнем регистре</a
                >
              </p>

              <p class="form__description">
                Широко распространена практика использования констант в качестве
                псевдонимов для трудно запоминаемых значений, которые известны
                до начала исполнения скрипта. Названия таких констант пишутся с
                использованием заглавных букв и подчёркивания.
              </p>

              <p class="form__syntax">const COLOR_RED = "#F00";</p>

              <p class="form__description">
                Название «константа» просто означает, что значение переменной
                никогда не меняется. Но есть константы, которые известны до
                выполнения (например, шестнадцатеричное значение для красного
                цвета), а есть константы, которые вычисляются во время
                выполнения сценария, но не изменяются после их первоначального
                назначения.
              </p>

              <p class="form__syntax">
                const pageLoadTime = /* время, потраченное на загрузку
                веб-страницы */;
              </p>

              <p class="form__description">
                Значение pageLoadTime неизвестно до загрузки страницы, поэтому
                её имя записано обычными, а не прописными буквами. Но это всё
                ещё константа, потому что она не изменяется после назначения.
              </p>

              <p class="form__description">
                Другими словами, константы с именами, записанными заглавными
                буквами, используются только как псевдонимы для «жёстко
                закодированных» значений.
              </p>

              <p class="form__subheading">
                <a
                  target="_blank"
                  rel="noopener"
                  href="https://learn.javascript.ru/variables#itogo"
                  class="form__link"
                >
                  Итого</a
                >
              </p>

              <p class="form__description">
                Мы можем объявить переменные для хранения данных с помощью
                ключевых слов var, let или const.
              </p>

              <p class="form__description">
                1. let – это современный способ объявления.
              </p>

              <p class="form__description">
                2. var – это устаревший способ объявления. Обычно мы редко
                используем его, но рассмотрим тонкие отличия от let в главе
                <a
                  target="_blank"
                  rel="noopener"
                  href="https://learn.javascript.ru/var"
                  class="form__link"
                >
                  Устаревшее ключевое слово "var"</a
                >
                Устаревшее ключевое слово "var" на случай, если это всё-таки вам
                понадобится.
              </p>

              <p class="form__description">
                3. const – похоже на let, но значение переменной не может
                изменяться.
              </p>

              <p class="form__description">
                4. Переменные должны быть названы таким образом, чтобы мы могли
                легко понять, что у них внутри.
              </p>

              <p class="form__description">
                5. Можно объявить две переменные через запятую
              </p>

              <p class="form__syntax">let admin, name;</p>

              <p class="form__subheading">Работа с переменными</p>

              <p class="form__description">
                1. Объявите две переменные: admin и name.
              </p>

              <p class="form__syntax">
                let admin, name; // можно объявить две переменные через запятую
              </p>

              <p class="form__description">
                2. Запишите строку "Джон" в переменную name.
              </p>

              <p class="form__syntax">name = "Джон";</p>

              <p class="form__description">
                3. Скопируйте значение из переменной name в admin.
              </p>

              <p class="form__syntax">admin = name;</p>

              <p class="form__description">
                4. Выведите на экран значение admin, используя функцию alert
                (должна показать «Джон»).
              </p>

              <p class="form__syntax">alert( admin );</p>

              <p class="form__description">
                5. Создайте переменную для названия нашей планеты. Как бы вы её
                назвали?
              </p>

              <p class="form__syntax">let ourPlanetName = "Земля";</p>

              <p class="form__description">
                Обратите внимание, мы могли бы использовать короткое имя planet,
                но тогда будет непонятно, о какой планете мы говорим. Лучше
                описать содержимое переменной подробнее, по крайней мере, до тех
                пор, пока имя переменной неСтанетСлишкомДлинным.
              </p>

              <p class="form__description">
                6. Создайте переменную для хранения имени текущего посетителя
                сайта. Как бы вы назвали такую переменную?
              </p>

              <p class="form__syntax">let currentUserName = "Джон";</p>

              <p class="form__description">
                Опять же, мы могли бы укоротить название до userName, если мы
                точно знаем, что это текущий пользователь. Современные редакторы
                и автодополнение ввода в них позволяют легко писать длинные
                названия переменных. Не экономьте буквы. Имена, состоящие из
                трёх слов, вполне нормальны.
              </p>
            </div>
          </div>
          <p class="form__subheading">
            <a
              target="_blank"
              rel="noopener"
              href="https://learn.javascript.ru/variables#tasks"
              class="form__link-tasks"
            >
              Задачи "Переменная"</a
            >
          </p>
        </section>
        <!-- Переменная -->

        <!-- Типы данных -->
        <section id="tip-dannih" class="form">
          <div class="form__bloc-info">
            <h1 class="form__heading">
              <a
                target="_blank"
                rel="noopener"
                href="https://learn.javascript.ru/types"
                class="form__link"
              >
                Типы данных</a
              >
            </h1>
            <div class="form__bloc-hidden">
              <p class="form__description">
                Значение в JavaScript всегда относится к данным определённого
                типа. Например, это может быть строка или число.
              </p>

              <p class="form__description">
                В JavaScript есть 8 основных типов.
              </p>

              <p class="form__description">
                1. number для любых чисел: целочисленных или чисел с плавающей
                точкой; целочисленные значения ограничены диапазоном ±(253-1).
              </p>

              <p class="form__description">
                2. bigint для целых чисел произвольной длины.
              </p>

              <p class="form__description">
                3. string для строк. Строка может содержать ноль или больше
                символов, нет отдельного символьного типа.
              </p>

              <p class="form__subdescription">
                В JavaScript существует три типа кавычек.
              </p>

              <p class="form__subdescription">Двойные кавычки: "Привет".</p>

              <p class="form__subdescription">Одинарные кавычки: 'Привет'.</p>

              <p class="form__subdescription">Обратные кавычки: `Привет`.</p>

              <p class="form__subdescription">
                Обратные же кавычки имеют расширенную функциональность. Они
                позволяют нам встраивать выражения в строку, заключая их в ${…}.
                Например:
              </p>

              <p class="form__subdescription">
                <b> let name = "Иван"; </b> <br />
                <br />
                // Вставим переменную <br />
                <b> alert( `Привет, ${name}!` ); </b> // Привет, Иван! <br />
                <br />
                // Вставим выражение <br />
                <b> alert( `результат: ${1 + 2}` );</b> // результат: 3 <br />
              </p>

              <p class="form__subdescription">
                Выражение внутри ${…} вычисляется, и его результат становится
                частью строки. Мы можем положить туда всё, что угодно:
                переменную name, или выражение 1 + 2, или что-то более сложное.
                Обратите внимание, что это можно делать только в обратных
                кавычках. Другие кавычки не имеют такой функциональности
                встраивания!
              </p>

              <p class="form__description">4. boolean для true/false.</p>

              <p class="form__description">
                5. null для неизвестных значений – отдельный тип, имеющий одно
                значение null.
              </p>

              <p class="form__description">
                6. undefined для неприсвоенных значений – отдельный тип, имеющий
                одно значение undefined.
              </p>

              <p class="form__description">
                7. object для более сложных структур данных.
              </p>

              <p class="form__description">
                8. symbol для уникальных идентификаторов.
              </p>

              <p class="form__subheading">
                Оператор
                <a
                  target="_blank"
                  rel="noopener"
                  href="https://learn.javascript.ru/types#type-typeof"
                  class="form__link"
                >
                  typeof</a
                >
                позволяет нам увидеть, какой тип данных сохранён в переменной.
              </p>

              <p class="form__description">
                Оператор typeof возвращает тип аргумента. Это полезно, когда мы
                хотим обрабатывать значения различных типов по-разному или
                просто хотим сделать проверку.
              </p>

              <p class="form__description">
                У него есть две синтаксические формы:
              </p>

              <p class="form__subdescription">
                1. Синтаксис оператора: typeof x.
              </p>

              <p class="form__subdescription">
                2. Синтаксис функции: typeof(x).
              </p>

              <p class="form__description">
                Другими словами, он работает со скобками или без скобок.
                Результат одинаковый.
              </p>

              <p class="form__subdescription">
                Возвращает строку с именем типа. Например, "string".
              </p>

              <p class="form__subdescription">
                Для null возвращается "object" – это ошибка в языке, на самом
                деле это не объект.
              </p>
            </div>
          </div>
          <p class="form__subheading">
            <a
              target="_blank"
              rel="noopener"
              href="https://learn.javascript.ru/types#tasks"
              class="form__link-tasks"
            >
              Задачи "Типы данных"</a
            >
          </p>
        </section>
        <!-- Типы данных -->

        <!-- alert, prompt, confirm -->
        <section id="alert-prompt-confirm" class="form">
          <div class="form__bloc-info">
            <h1 class="form__heading">
              Взаимодействие:
              <a
                target="_blank"
                rel="noopener"
                href="https://learn.javascript.ru/alert-prompt-confirm"
                class="form__link"
              >
                alert, prompt, confirm</a
              >
            </h1>
            <div class="form__bloc-hidden">
              <p class="form__description">
                Так как мы будем использовать браузер как демо-среду, нам нужно
                познакомиться с несколькими функциями его интерфейса, а именно:
                alert, prompt и confirm.
              </p>

              <p class="form__subheading">
                <a
                  target="_blank"
                  rel="noopener"
                  href="https://learn.javascript.ru/alert-prompt-confirm#alert"
                  class="form__link"
                >
                  alert</a
                >
              </p>

              <p class="form__description">
                Эта функция показывает пользователю сообщение и ждёт, пока он
                нажмёт кнопку «ОК». Например:
              </p>

              <p class="form__syntax">alert("Hello");</p>

              <p class="form__description">
                Это небольшое окно с сообщением называется
                <b> модальным окном.</b> Понятие <b> модальное </b> означает,
                что пользователь не может взаимодействовать с интерфейсом
                остальной части страницы, нажимать на другие кнопки и т.д. до
                тех пор, пока взаимодействует с окном. В данном случае – пока не
                будет нажата кнопка «OK».
              </p>

              <p class="form__subheading">
                <a
                  target="_blank"
                  rel="noopener"
                  href="https://learn.javascript.ru/alert-prompt-confirm#prompt"
                  class="form__link"
                >
                  prompt</a
                >
              </p>

              <p class="form__description">
                показывает сообщение и запрашивает ввод текста от пользователя.
                Возвращает напечатанный в поле ввода текст или null, если была
                нажата кнопка «Отмена» или Esc с клавиатуры.
              </p>

              <p class="form__description">
                Функция prompt принимает два аргумента:
              </p>

              <p class="form__syntax">result = prompt(title, [default]);</p>

              <p class="form__description">
                Этот код отобразит модальное окно с текстом, полем для ввода
                текста и кнопками OK/Отмена.
              </p>

              <p class="form__subdescription">
                <b> title</b> Текст для отображения в окне.
              </p>

              <p class="form__subdescription">
                <b> default </b> Необязательный второй параметр, который
                устанавливает начальное значение в поле для текста в окне.
              </p>

              <p class="form__attention">
                Квадратные скобки <b> [...] </b> в описанном выше синтаксисе
                означают, что параметр факультативный, необязательный.
              </p>

              <p class="form__description">
                Пользователь может напечатать что-либо в поле ввода и нажать OK.
                Введённый текст будет присвоен переменной <b> result</b>.
                Пользователь также может отменить ввод нажатием на кнопку
                «Отмена» или нажав на клавишу Esc. В этом случае значением
                result станет null.
              </p>

              <p class="form__description">
                Вызов prompt возвращает текст, указанный в поле для ввода, или
                null, если ввод отменён пользователем. Например:
              </p>

              <p class="form__subdescription">
                let age = prompt('Сколько тебе лет?', 100); <br />
                alert(`Тебе ${age} лет!`); // Тебе 100 лет!
              </p>

              <p class="form__description">
                Второй параметр является необязательным, но если не указать его,
                то Internet Explorer вставит строку "undefined" в поле для
                ввода.
              </p>

              <p class="form__subheading">
                <a
                  target="_blank"
                  rel="noopener"
                  href="https://learn.javascript.ru/alert-prompt-confirm#confirm"
                  class="form__link"
                >
                  confirm</a
                >
              </p>

              <p class="form__syntax">result = confirm(question);</p>

              <p class="form__description">
                Функция confirm отображает модальное окно с текстом вопроса
                question и двумя кнопками: OK и Отмена.
              </p>

              <p class="form__description">
                Результат – true, если нажата кнопка OK. В других случаях –
                false. Например:
              </p>

              <p class="form__subdescription">
                let isBoss = confirm("Ты здесь главный?"); <br />
                alert( isBoss ); // true, если нажата OK
              </p>

              <p class="form__description">
                показывает сообщение и ждёт, пока пользователь нажмёт OK или
                Отмена. Возвращает true, если нажата OK, и false, если нажата
                кнопка «Отмена» или Esc с клавиатуры.
              </p>

              <p class="form__description">
                Все эти методы являются модальными: останавливают выполнение
                скриптов и не позволяют пользователю взаимодействовать с
                остальной частью страницы до тех пор, пока окно не будет
                закрыто.
              </p>

              <p class="form__subheading">Задачи</p>

              <p class="form__description">
                Создайте страницу, которая спрашивает имя у пользователя и
                выводит его.
              </p>

              <p class="form__subdescription">
                let name = prompt("Ваше имя?", ""); <br />
                alert(name);
              </p>
            </div>
          </div>
          <p class="form__subheading">
            <a
              target="_blank"
              rel="noopener"
              href="https://learn.javascript.ru/alert-prompt-confirm#tasks"
              class="form__link-tasks"
            >
              Задачи "alert, prompt, confirm"</a
            >
          </p>
        </section>
        <!-- alert, prompt, confirm -->

        <!-- Преобразование типов -->
        <section id="preobrazovanie-tipov" class="form">
          <div class="form__bloc-info">
            <h1 class="form__heading">
              <a
                target="_blank"
                rel="noopener"
                href="https://learn.javascript.ru/type-conversions"
                class="form__link"
              >
                Преобразование типов (примитивных значений)</a
              >
            </h1>
            <div class="form__bloc-hidden">
              <p class="form__description">
                Чаще всего операторы и функции автоматически приводят переданные
                им значения к нужному типу. Например,
                <b> alert</b> автоматически преобразует любое значение к строке.
                <b> Математические операторы</b> преобразуют значения к числам.
                Есть также случаи, когда нам нужно явно преобразовать значение в
                ожидаемый тип.
              </p>

              <p class="form__subheading">
                <a
                  target="_blank"
                  rel="noopener"
                  href="https://learn.javascript.ru/type-conversions#strokovoe-preobrazovanie"
                  class="form__link"
                >
                  Строковое преобразование</a
                >
              </p>

              <p class="form__description">
                Строковое преобразование происходит, когда требуется
                представление чего-либо в виде строки. Например,
                <b> alert(value)</b> преобразует значение к строке. Также мы
                можем использовать функцию <b> String(value)</b>, чтобы
                преобразовать значение к строке:
              </p>

              <p class="form__subdescription">
                let value = true; <br />
                alert(typeof value); // boolean <br />
                value = String(value); // теперь value это строка "true" <br />
                alert(typeof value); // string
              </p>

              <p class="form__description">
                Преобразование происходит очевидным образом. false становится
                "false", null становится "null" и т.п.
              </p>

              <p class="form__subheading">
                <a
                  target="_blank"
                  rel="noopener"
                  href="https://learn.javascript.ru/type-conversions#chislennoe-preobrazovanie"
                  class="form__link"
                >
                  Численное преобразование</a
                >
              </p>

              <p class="form__description">
                Численное преобразование происходит в математических функциях и
                выражениях. Например, когда операция деления / применяется не к
                числу:
              </p>

              <p class="form__subdescription">
                alert( "6" / "2" ); // 3, строки преобразуются в числа
              </p>

              <p class="form__description">
                Мы можем использовать функцию Number(value), чтобы явно
                преобразовать value к числу:
              </p>

              <p class="form__subdescription">
                let str = "123"; <br />
                alert(typeof str); // string <br />
                let num = Number(str); // становится числом 123 <br />
                alert(typeof num); // number
              </p>

              <p class="form__description">
                Явное преобразование часто применяется, когда мы ожидаем
                получить число из строкового контекста, например из текстовых
                полей форм. Если строка не может быть явно приведена к числу, то
                результатом преобразования будет NaN. Например:
              </p>

              <p class="form__subdescription">
                let age = Number("Любая строка вместо числа"); <br />
                alert(age); // NaN, преобразование не удалось
              </p>

              <p class="form__subheading">Правила численного преобразования:</p>

              <p class="form__subdescription">
                <b> Значение</b> Преобразуется в…
              </p>

              <p class="form__subdescription"><b> undefined </b> NaN</p>

              <p class="form__subdescription">
                <b> null </b>
                0
              </p>

              <p class="form__subdescription">
                <b> true / false </b>
                1 / 0
              </p>

              <p class="form__subdescription">
                <b> string </b>
                Пробельные символы по краям обрезаются. Далее, если остаётся
                пустая строка, то получаем 0, иначе из непустой строки
                «считывается» число. При ошибке результат NaN.
              </p>

              <p class="form__description">
                Учтите, что null и undefined ведут себя по-разному. Так, null
                становится нулём, тогда как undefined приводится к NaN.
              </p>

              <p class="form__description">
                Большинство математических операторов также производит данное
                преобразование.
              </p>

              <p class="form__subheading">
                <a
                  target="_blank"
                  rel="noopener"
                  href="https://learn.javascript.ru/type-conversions#logicheskoe-preobrazovanie"
                  class="form__link"
                >
                  Логическое преобразование</a
                >
              </p>

              <p class="form__description">
                Происходит в логических операциях. Может быть вызвано с помощью
                Boolean(value). Подчиняется правилам:
              </p>

              <p class="form__subdescription"><b> Значение</b> Становится…</p>

              <p class="form__subdescription">
                <b> 0, null, undefined, NaN, "" </b>
                false
              </p>

              <p class="form__subdescription">
                <b> любое другое значение </b>
                true
              </p>

              <p class="form__description">
                Большую часть из этих правил легко понять и запомнить. Особые
                случаи, в которых часто допускаются ошибки:
              </p>

              <p class="form__subdescription">
                undefined при численном преобразовании становится NaN, не 0.
              </p>

              <p class="form__subdescription">
                "0" и строки из одних пробелов типа " " при логическом
                преобразовании всегда true
              </p>
            </div>
          </div>
          <p class="form__subheading">
            <a target="_blank" rel="noopener" href="#" class="form__link-tasks">
              Задачи "Преобразование типов" пусто пока</a
            >
          </p>
        </section>
        <!-- Преобразование типов -->

        <!-- Базовые операторы, математика -->
        <section id="operatori-bazic" class="form">
          <div class="form__bloc-info">
            <h1 class="form__heading">
              <a
                target="_blank"
                rel="noopener"
                href="https://learn.javascript.ru/operators"
                class="form__link"
              >
                Базовые операторы, математика</a
              >
            </h1>
            <div class="form__bloc-hidden">
              <p class="form__subheading">
                <a
                  target="_blank"
                  rel="noopener"
                  href="https://learn.javascript.ru/operators#terminy-unarnyy-binarnyy-operand"
                  class="form__link"
                >
                  Термины: «унарный», «бинарный», «операнд»</a
                >
              </p>

              <p class="form__description">
                Прежде, чем мы двинемся дальше, давайте разберёмся с
                терминологией.
              </p>

              <p class="form__subdescription">
                <b> Операнд</b> – то, к чему применяется оператор. Например, в
                умножении 5 * 2 есть два операнда: левый операнд равен 5, а
                правый операнд равен 2. Иногда их называют
                <b> «аргументами»</b> вместо «операндов».
              </p>

              <p class="form__subdescription">
                <b> Унарным</b> называется оператор, который применяется к
                одному операнду. Например, оператор унарный минус
                <b> "-"</b> меняет знак числа на противоположный:
              </p>

              <p class="form__subdescription">
                let x = 1; <br />
                x = -x; <br />
                alert( x ); // -1, применили унарный минус
              </p>

              <p class="form__subdescription">
                <b> Бинарным</b> называется оператор, который применяется к двум
                операндам. Тот же минус существует и в бинарной форме:
              </p>

              <p class="form__subdescription">
                let x = 1, y = 3; <br />
                alert( y - x ); // 2, бинарный минус вычитает значения
              </p>

              <p class="form__description">
                Формально, в последних примерах мы говорим о двух разных
                операторах, использующих один символ: оператор отрицания
                (унарный оператор, который обращает знак) и оператор вычитания
                (бинарный оператор, который вычитает одно число из другого).
              </p>

              <p class="form__subheading">
                <a
                  target="_blank"
                  rel="noopener"
                  href="https://learn.javascript.ru/operators#matematika"
                  class="form__link"
                >
                  Математика</a
                >
              </p>

              <p class="form__description">
                Поддерживаются следующие математические операторы:
              </p>

              <p class="form__subdescription">Сложение +,</p>

              <p class="form__subdescription">Вычитание -,</p>

              <p class="form__subdescription">Умножение *,</p>

              <p class="form__subdescription">Деление /,</p>

              <p class="form__subdescription">Взятие остатка от деления %,</p>

              <p class="form__subdescription">Возведение в степень **.</p>

              <p class="form__subdescription">
                Первые четыре оператора очевидны, а про % и ** стоит сказать
                несколько слов.
              </p>

              <p class="form__subheading">
                <a
                  target="_blank"
                  rel="noopener"
                  href="https://learn.javascript.ru/operators#vzyatie-ostatka"
                  class="form__link"
                >
                  Взятие остатка %</a
                >
              </p>

              <p class="form__description">
                Оператор взятия остатка %, несмотря на обозначение, никакого
                отношения к процентам не имеет. Результат a % b – это остаток от
                целочисленного деления a на b. Например:
              </p>

              <p class="form__subdescription">
                alert( 5 % 2 ); // 1, остаток от деления 5 на 2 <br />
                alert( 8 % 3 ); // 2, остаток от деления 8 на 3
              </p>

              <p class="form__subheading">
                <a
                  target="_blank"
                  rel="noopener"
                  href="https://learn.javascript.ru/operators#vozvedenie-v-stepen"
                  class="form__link"
                >
                  Возведение в степень **</a
                >
              </p>

              <p class="form__description">
                В выражении a ** b оператор возведения в степень умножает a на
                само себя b раз. Например:
              </p>

              <p class="form__subdescription">
                alert( 2 ** 2 ); // 4 (2 умножено на себя 2 раза) <br />
                alert( 2 ** 3 ); // 8 (2 * 2 * 2, 3 раза) <br />
                alert( 2 ** 4 ); // 16 (2 * 2 * 2 * 2, 4 раза)
              </p>

              <p class="form__description">
                Математически, оператор работает и для нецелых чисел. Например,
                квадратный корень является возведением в степень 1/2:
              </p>

              <p class="form__subdescription">
                alert( 4 ** (1/2) ); // 2 (степень 1/2 эквивалентна взятию
                квадратного корня) <br />
                alert( 8 ** (1/3) ); // 2 (степень 1/3 эквивалентна взятию
                кубического корня)
              </p>

              <p class="form__subheading">
                <a
                  target="_blank"
                  rel="noopener"
                  href="https://learn.javascript.ru/operators#slozhenie-strok-pri-pomoschi-binarnogo"
                  class="form__link"
                >
                  Сложение строк при помощи бинарного +</a
                >
              </p>

              <p class="form__description">
                Обычно при помощи плюса '+' складывают числа. Но если бинарный
                оператор '+' применить к строкам, то он их объединяет в одну:
              </p>

              <p class="form__subdescription">
                let s = "моя" + "строка"; alert(s); // моястрока
              </p>

              <p class="form__description">
                Обратите внимание, если хотя бы один операнд является строкой,
                то второй будет также преобразован в строку. Например:
              </p>

              <p class="form__subdescription">
                alert( '1' + 2 ); // "12" <br />
                alert( 2 + '1' ); // "21"
              </p>

              <p class="form__description">
                Как видите, не важно, первый или второй операнд является
                строкой. Вот пример посложнее:
              </p>

              <p class="form__subdescription">
                alert(2 + 2 + '1' ); // будет "41", а не "221"
              </p>

              <p class="form__description">
                Здесь операторы работают один за другим. Первый + складывает два
                числа и возвращает 4, затем следующий + объединяет результат со
                строкой, производя действие 4 + '1' = 41.
              </p>

              <p class="form__description">
                Сложение и преобразование строк — это особенность бинарного
                плюса +. Другие арифметические операторы работают только с
                числами и всегда преобразуют операнды в числа. Например,
                вычитание и деление:
              </p>

              <p class="form__subdescription">
                alert( 6 - '2' ); // 4, '2' приводится к числу <br />
                alert( '6' / '2' ); // 3, оба операнда приводятся к числам
              </p>

              <p class="form__subheading">
                <a
                  target="_blank"
                  rel="noopener"
                  href="https://learn.javascript.ru/operators#privedenie-k-chislu-unarnyy"
                  class="form__link"
                >
                  Приведение к числу, унарный +</a
                >
              </p>

              <p class="form__description">
                Плюс + существует в двух формах: бинарной, которую мы
                использовали выше, и унарной.
              </p>

              <p class="form__description">
                Унарный, то есть применённый к одному значению, плюс + ничего не
                делает с числами. Но если операнд не число, унарный плюс
                преобразует его в число. Например:
              </p>

              <p class="form__subdescription">
                // Не влияет на числа <br />
                let x = 1; <br />
                alert( +x ); // 1 <br />
                let y = -2; <br />
                alert( +y ); // -2 <br />
                // Преобразует не числа в числа <br />
                alert( +true ); // 1 <br />
                alert( +"" ); // 0
              </p>

              <p class="form__description">
                На самом деле это то же самое, что и Number(...), только короче.
              </p>

              <p class="form__description">
                Необходимость преобразовывать строки в числа возникает очень
                часто. Например, обычно значения полей HTML-формы — это строки.
                А что, если их нужно, к примеру, сложить? Бинарный плюс сложит
                их как строки:
              </p>

              <p class="form__subdescription">
                let apples = "2"; <br />
                let oranges = "3"; <br />
                alert( apples + oranges ); // "23", так как бинарный плюс
                объединяет строки <br />
              </p>

              <p class="form__description">
                Поэтому используем унарный плюс, чтобы преобразовать к числу:
              </p>

              <p class="form__subdescription">
                let apples = "2"; <br />
                let oranges = "3"; <br />
                // оба операнда предварительно преобразованы в числа alert(
                +apples + +oranges ); // <br />
                // более длинный вариант <br />
                // alert( Number(apples) + Number(oranges) ); // 5
              </p>

              <p class="form__description">
                С точки зрения математика, такое изобилие плюсов выглядит
                странным. Но с точки зрения программиста тут нет ничего
                особенного: сначала выполнятся унарные плюсы, которые приведут
                строки к числам, а затем бинарный '+' их сложит.
              </p>

              <p class="form__description">
                Почему унарные плюсы выполнились до бинарного сложения? Как мы
                сейчас увидим, дело в их приоритете.
              </p>

              <p class="form__subheading">
                <a
                  target="_blank"
                  rel="noopener"
                  href="https://learn.javascript.ru/operators#prioritet-operatorov"
                  class="form__link"
                >
                  Приоритет операторов</a
                >
              </p>

              <p class="form__description">
                В том случае, если в выражении есть несколько операторов –
                порядок их выполнения определяется приоритетом, или, другими
                словами, существует определённый порядок выполнения операторов.
              </p>

              <p class="form__description">
                Из школы мы знаем, что умножение в выражении 1 + 2 * 2
                выполнится раньше сложения. Это как раз и есть «приоритет».
                Говорят, что умножение имеет более высокий приоритет, чем
                сложение.
              </p>

              <p class="form__description">
                Скобки важнее, чем приоритет, так что, если мы не удовлетворены
                порядком по умолчанию, мы можем использовать их, чтобы изменить
                приоритет. Например, написать (1 + 2) * 2.
              </p>

              <p class="form__description">
                В JavaScript много операторов. Каждый оператор имеет
                соответствующий номер приоритета. Тот, у кого это число больше,
                – выполнится раньше. Если приоритет одинаковый, то порядок
                выполнения – слева направо.
              </p>

              <p class="form__description">
                Отрывок из
                <a
                  target="_blank"
                  rel="noopener"
                  href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/Operator_Precedence"
                  class="form__link"
                >
                  таблицы приоритетов</a
                >
                (нет необходимости всё запоминать, обратите внимание, что
                приоритет унарных операторов выше, чем соответствующих
                бинарных):
              </p>

              <p class="form__subdescription">17 унарный плюс +</p>

              <p class="form__subdescription">17 унарный минус -</p>

              <p class="form__subdescription">16 возведение в степень **</p>

              <p class="form__subdescription">15 умножение *</p>

              <p class="form__subdescription">15 деление /</p>

              <p class="form__subdescription">13 сложение +</p>

              <p class="form__subdescription">13 вычитание -</p>

              <p class="form__subdescription">3 присваивание =</p>

              <p class="form__description">
                выражении "+apples + +oranges" сначала выполнятся унарные плюсы,
                а затем сложение.
              </p>

              <p class="form__subheading">
                <a
                  target="_blank"
                  rel="noopener"
                  href="https://learn.javascript.ru/operators#prisvaivanie"
                  class="form__link"
                >
                  Присваивание</a
                >
              </p>

              <p class="form__description">
                Давайте отметим, что в таблице приоритетов также есть оператор
                присваивания =. У него один из самых низких приоритетов: 3.
              </p>

              <p class="form__description">
                Именно поэтому, когда переменной что-либо присваивают, например,
                x = 2 * 2 + 1, то сначала выполнится арифметика, а уже затем
                произойдёт присваивание = с сохранением результата в x.
              </p>

              <p class="form__subdescription">
                let x = 2 * 2 + 1; <br />
                alert( x ); // 5
              </p>

              <p class="form__subheading">
                <a
                  target="_blank"
                  rel="noopener"
                  href="https://learn.javascript.ru/operators#prisvaivanie-vozvraschaet-znachenie"
                  class="form__link"
                >
                  Присваивание = возвращает значение</a
                >
              </p>

              <p class="form__description">
                Тот факт, что = является оператором, а не «магической»
                конструкцией языка, имеет интересные последствия.
              </p>

              <p class="form__description">
                Большинство операторов в JavaScript возвращают значение. Для
                некоторых это очевидно, например сложение + или умножение *. Но
                и оператор присваивания не является исключением.
              </p>

              <p class="form__description">
                Вызов x = value записывает value в x и возвращает его.
              </p>

              <p class="form__description">
                Благодаря этому присваивание можно использовать как часть более
                сложного выражения:
              </p>

              <p class="form__subdescription">
                let a = 1; <br />
                let b = 2; <br />
                let c = 3 - (a = b + 1); <br />
                alert( a ); // 3 <br />
                alert( c ); // 0
              </p>

              <p class="form__description">
                В примере выше результатом (a = b + 1) будет значение, которое
                присваивается переменной a (то есть 3). Потом оно используется
                для дальнейших вычислений.
              </p>

              <p class="form__description">
                Забавное применение присваивания, не так ли? Нам нужно понимать,
                как это работает, потому что иногда это можно увидеть в
                JavaScript-библиотеках.
              </p>

              <p class="form__description">
                Однако писать самим в таком стиле не рекомендуется. Такие трюки
                не сделают ваш код более понятным или читабельным.
              </p>

              <p class="form__subheading">
                <a
                  target="_blank"
                  rel="noopener"
                  href="https://learn.javascript.ru/operators#prisvaivanie-po-tsepochke"
                  class="form__link"
                >
                  Присваивание по цепочке</a
                >
              </p>

              <p class="form__description">
                Рассмотрим ещё одну интересную возможность: цепочку
                присваиваний.
              </p>

              <p class="form__subdescription">
                let a, b, c; <br />
                a = b = c = 2 + 2; <br />
                alert( a ); // 4 <br />
                alert( b ); // 4 <br />
                alert( c ); // 4
              </p>

              <p class="form__description">
                Такое присваивание работает справа налево. Сначала вычисляется
                самое правое выражение 2 + 2, и затем результат присваивается
                переменным слева: c, b и a. В конце у всех переменных будет одно
                значение.
              </p>

              <p class="form__description">
                Опять-таки, чтобы код читался легче, лучше разделять подобные
                конструкции на несколько строчек:
              </p>

              <p class="form__subdescription">
                c = 2 + 2; <br />
                b = c; <br />
                a = c;
              </p>

              <p class="form__description">
                Польза от такого стиля особенно ощущается при быстром просмотре
                кода.
              </p>

              <p class="form__subheading">
                <a
                  target="_blank"
                  rel="noopener"
                  href="https://learn.javascript.ru/operators#sokraschyonnaya-arifmetika-s-prisvaivaniem"
                  class="form__link"
                >
                  Сокращённая арифметика с присваиванием</a
                >
              </p>

              <p class="form__description">
                Часто нужно применить оператор к переменной и сохранить
                результат в ней же. Например:
              </p>

              <p class="form__subdescription">
                let n = 2; <br />
                n = n + 5; <br />
                n = n * 2;
              </p>

              <p class="form__description">
                Эту запись можно укоротить при помощи совмещённых операторов +=
                и *=:
              </p>

              <p class="form__subdescription">
                let n = 2; <br />
                n += 5; // теперь n = 7 (работает как n = n + 5) <br />
                n *= 2; // теперь n = 14 (работает как n = n * 2) <br />
                alert( n ); // 14
              </p>

              <p class="form__description">
                Подобные краткие формы записи существуют для всех арифметических
                и побитовых операторов: /=, -= и так далее.
              </p>

              <p class="form__description">
                Вызов с присваиванием имеет в точности такой же приоритет, как
                обычное присваивание, то есть выполнится после большинства
                других операций:
              </p>

              <p class="form__subdescription">
                let n = 2; <br />
                n *= 3 + 5 <br />
                alert( n ); // 16 (сначала выполнится правая часть, выражение
                идентично n *= 8)
              </p>

              <p class="form__subheading">
                <a
                  target="_blank"
                  rel="noopener"
                  href="https://learn.javascript.ru/operators#inkrement-dekrement"
                  class="form__link"
                >
                  Инкремент/декремент</a
                >
              </p>

              <p class="form__description">
                Одной из наиболее частых числовых операций является увеличение
                или уменьшение на единицу. Для этого существуют даже специальные
                операторы:
              </p>

              <p class="form__subheading">
                <b> Инкремент ++</b> увеличивает переменную на 1:
              </p>

              <p class="form__subdescription">
                let counter = 2; <br />
                counter++; // работает как counter = counter + 1, просто запись
                короче <br />
                alert( counter ); // 3
              </p>

              <p class="form__subheading">
                <b>Декремент --</b> уменьшает переменную на 1:
              </p>

              <p class="form__subdescription">
                let counter = 2; <br />
                counter--; // работает как counter = counter - 1, просто запись
                короче <br />
                alert( counter ); // 1
              </p>

              <p class="form__attention">
                <b>Важно:</b> <br />
                Инкремент/декремент можно применить только к переменной. Попытка
                использовать его на значении, типа 5++, приведёт к ошибке.
              </p>

              <p class="form__subdescription">
                Когда оператор идёт после переменной — это «постфиксная форма»:
                counter++.
              </p>

              <p class="form__subdescription">
                «Префиксная форма» — это когда оператор идёт перед переменной:
                ++counter.
              </p>

              <p class="form__description">
                Обе эти инструкции делают одно и то же: увеличивают counter на
                1.
              </p>

              <p class="form__description">
                Есть ли разница между ними? Да, но увидеть её мы сможем, только
                если будем использовать значение, которое возвращают ++/--.
              </p>

              <p class="form__description">
                Давайте проясним этот момент. Как мы знаем, все операторы
                возвращают значение. Операторы инкремента/декремента не
                исключение. Префиксная форма возвращает новое значение, в то
                время как постфиксная форма возвращает старое (до
                увеличения/уменьшения числа).
              </p>

              <p class="form__description">
                Чтобы увидеть разницу, вот небольшой пример:
              </p>

              <p class="form__subdescription">
                let counter = 1; <br />
                let a = ++counter; // (*) <br />
                alert(a); // 2
              </p>

              <p class="form__description">
                В строке (*) префиксная форма ++counter увеличивает counter и
                возвращает новое значение 2. Так что alert покажет 2.
              </p>

              <p class="form__description">
                Теперь посмотрим на постфиксную форму:
              </p>

              <p class="form__subdescription">
                let counter = 1; <br />
                let a = counter++; // (*) меняем ++counter на counter++ <br />
                alert(a); // 1
              </p>

              <p class="form__description">
                В строке (*) постфиксная форма counter++ также увеличивает
                counter, но возвращает старое значение (которое было до
                увеличения). Так что alert покажет 1.
              </p>

              <p class="form__description">Подведём итоги:</p>

              <p class="form__subdescription">
                Если результат оператора не используется, а нужно только
                увеличить/уменьшить переменную, тогда без разницы, какую форму
                использовать:
              </p>

              <p class="form__subdescription">
                let counter = 0; <br />
                counter++; <br />
                ++counter; <br />
                alert( counter ); // 2, обе строки сделали одно и то же
              </p>

              <p class="form__subdescription">
                Если хочется тут же использовать результат, то нужна префиксная
                форма:
              </p>

              <p class="form__subdescription">
                let counter = 0; <br />
                alert( ++counter ); // 1
              </p>

              <p class="form__subdescription">
                Если нужно увеличить и при этом получить значение переменной до
                увеличения – нужна постфиксная форма:
              </p>

              <p class="form__subdescription">
                let counter = 0; <br />
                alert( counter++ ); // 0
              </p>

              <p class="form__attention">
                <b>Инкремент/декремент можно использовать в любых выражениях</b>
              </p>

              <p class="form__description">
                Операторы ++/-- могут также использоваться внутри выражений. Их
                приоритет выше, чем у большинства других арифметических
                операций. Например:
              </p>

              <p class="form__subdescription">
                let counter = 1; <br />
                alert( 2 * ++counter ); // 4 <br />
              </p>

              <p class="form__description">Сравните с:</p>

              <p class="form__subdescription">
                let counter = 1; <br />
                alert( 2 * counter++ ); // 2, потому что counter++ возвращает
                "старое" значение
              </p>

              <p class="form__description">
                Хотя технически здесь всё в порядке, такая запись обычно делает
                код менее читабельным. Одна строка выполняет множество действий
                – нехорошо
              </p>

              <p class="form__description">
                При беглом чтении кода можно с лёгкостью пропустить такой
                counter++, и будет неочевидно, что переменная увеличивается.
              </p>

              <p class="form__description">
                Лучше использовать стиль «одна строка – одно действие»:
              </p>

              <p class="form__subdescription">
                let counter = 1; <br />
                alert( 2 * counter ); <br />
                counter++;
              </p>

              <p class="form__subheading">
                <a
                  target="_blank"
                  rel="noopener"
                  href="https://learn.javascript.ru/operators#pobitovye-operatory"
                  class="form__link"
                >
                  Побитовые операторы</a
                >
              </p>

              <p class="form__description">
                Побитовые операторы работают с 32-разрядными целыми числами (при
                необходимости приводят к ним), на уровне их внутреннего
                двоичного представления.
              </p>

              <p class="form__subheading">
                <a
                  target="_blank"
                  rel="noopener"
                  href="https://learn.javascript.ru/operators#operator-zapyataya"
                  class="form__link"
                >
                  Оператор «запятая»
                </a>
              </p>

              <p class="form__description">
                Оператор «запятая» (,) редко применяется и является одним из
                самых необычных. Иногда он используется для написания более
                короткого кода, поэтому нам нужно знать его, чтобы понимать, что
                при этом происходит.
              </p>

              <p class="form__description">
                Оператор «запятая» предоставляет нам возможность вычислять
                несколько выражений, разделяя их запятой ,. Каждое выражение
                выполняется, но возвращается результат только последнего.
                Например:
              </p>

              <p class="form__subdescription">
                let a = (1 + 2, 3 + 4); <br />
                alert( a ); // 7 (результат вычисления 3 + 4)
              </p>

              <p class="form__description">
                Первое выражение 1 + 2 выполняется, а результат отбрасывается.
                Затем идёт 3 + 4, выражение выполняется и возвращается
                результат.
              </p>

              <p class="form__attention">
                Запятая имеет очень низкий приоритет
              </p>

              <p class="form__subdescription">
                Пожалуйста, обратите внимание, что оператор " , " имеет очень
                низкий приоритет, ниже =, поэтому скобки важны в приведённом
                выше примере.
              </p>

              <p class="form__subdescription">
                Без них в a = 1 + 2, 3 + 4 сначала выполнится +, суммируя числа
                в a = 3, 7, затем оператор присваивания = присвоит a = 3, а то,
                что идёт дальше, будет игнорировано. Всё так же, как в (a = 1 +
                2), 3 + 4.
              </p>

              <p class="form__description">
                Зачем нам оператор, который отбрасывает всё, кроме последнего
                выражения?
              </p>

              <p class="form__description">
                Иногда его используют в составе более сложных конструкций, чтобы
                сделать несколько действий в одной строке. Например:
              </p>

              <p class="form__subdescription">
                // три операции в одной строке <br />
                for (a = 1, b = 3, c = a * b; a &lt; 10; a++) { <br />
                ... <br />
                }
              </p>

              <p class="form__description">
                Такие трюки используются во многих JavaScript-фреймворках. Вот
                почему мы упоминаем их. Но обычно они не улучшают читабельность
                кода, поэтому стоит хорошо подумать, прежде чем их использовать.
              </p>

              <p class="form__subheading">
                <a
                  target="_blank"
                  rel="noopener"
                  href="https://learn.javascript.ru/operators#tasks"
                  class="form__link"
                >
                  Задачи</a
                >
              </p>
            </div>
          </div>
          <p class="form__subheading">
            <a
              target="_blank"
              rel="noopener"
              href="https://learn.javascript.ru/operators#tasks"
              class="form__link-tasks"
            >
              Задачи "Базовые операторы, математика"
            </a>
          </p>
        </section>
        <!-- Базовые операторы, математика -->

        <!-- Операторы сравнения -->
        <section id="operatori-sravneniy" class="form">
          <div class="form__bloc-info">
            <h1 class="form__heading">
              <a
                target="_blank"
                rel="noopener"
                href="https://learn.javascript.ru/comparison"
                class="form__link"
              >
                Операторы сравнения</a
              >
            </h1>
            <div class="form__bloc-hidden">
              <p class="form__description">
                Многие операторы сравнения известны нам из математики. В
                JavaScript они записываются так:
              </p>

              <p class="form__subdescription">
                Больше/меньше: a &gt; b, a &lt; b.
              </p>

              <p class="form__subdescription">
                Больше/меньше или равно: a &gt;= b, a &lt;= b.
              </p>

              <p class="form__subdescription">
                Равно: a == b. Обратите внимание, для сравнения используется
                двойной знак равенства ==. Один знак равенства a = b означал бы
                присваивание.
              </p>

              <p class="form__subdescription">
                Не равно. В математике обозначается символом ≠, но в JavaScript
                записывается как a != b.
              </p>

              <p class="form__description">
                В этом разделе мы больше узнаем про то, какие бывают сравнения,
                как язык с ними работает и к каким неожиданностям мы должны быть
                готовы. В конце вы найдёте хороший рецепт того, как избегать
                «причуд» сравнения в JavaScript.
              </p>

              <p class="form__subheading">
                <a
                  target="_blank"
                  rel="noopener"
                  href="https://learn.javascript.ru/comparison#rezultat-sravneniya-imeet-logicheskiy-tip"
                  class="form__link"
                >
                  Результат сравнения имеет логический тип</a
                >
              </p>

              <p class="form__description">
                Все операторы сравнения возвращают значение логического типа:
              </p>

              <p class="form__subdescription">
                <b> true</b> – означает «да», «верно», «истина».
              </p>

              <p class="form__subdescription">
                <b> false</b> – означает «нет», «неверно», «ложь».
              </p>

              <p class="form__subdescription">
                alert( 2 > 1 ); // true (верно) <br />
                alert( 2 == 1 ); // false (неверно) <br />
                alert( 2 != 1 ); // true (верно)
              </p>

              <p class="form__description">
                Результат сравнения можно присвоить переменной, как и любое
                значение:
              </p>

              <p class="form__subdescription">
                let result = 5 > 4; // результат сравнения присваивается
                переменной result <br />
                alert( result ); // true
              </p>

              <p class="form__subheading">
                <a
                  target="_blank"
                  rel="noopener"
                  href="https://learn.javascript.ru/comparison#sravnenie-strok"
                  class="form__link"
                >
                  Сравнение строк</a
                >
              </p>

              <p class="form__description">
                Чтобы определить, что одна строка больше другой, JavaScript
                использует «алфавитный» или «лексикографический» порядок.
                Другими словами, строки сравниваются посимвольно. Например:
              </p>

              <p class="form__subdescription">
                alert( 'Я' > 'А' ); // true <br />
                alert( 'Коты' > 'Кода' ); // true <br />
                alert( 'Сонный' > 'Сон' ); // true
              </p>

              <p class="form__description">
                Алгоритм сравнения двух строк довольно прост:
              </p>

              <p class="form__subdescription">
                1. Сначала сравниваются первые символы строк.
              </p>

              <p class="form__subdescription">
                2. Если первый символ первой строки больше (меньше), чем первый
                символ второй, то первая строка больше (меньше) второй.
                Сравнение завершено.
              </p>

              <p class="form__subdescription">
                3. Если первые символы равны, то таким же образом сравниваются
                уже вторые символы строк.
              </p>

              <p class="form__subdescription">
                4. Сравнение продолжается, пока не закончится одна из строк.
              </p>

              <p class="form__subdescription">
                5. Если обе строки заканчиваются одновременно, то они равны.
                Иначе, большей считается более длинная строка.
              </p>

              <p class="form__description">
                В примерах выше сравнение 'Я' > 'А' завершится на первом шаге,
                тогда как строки 'Коты' и 'Кода' будут сравниваться посимвольно:
              </p>

              <p class="form__subdescription">1. К равна К.</p>

              <p class="form__subdescription">2. о равна о.</p>

              <p class="form__subdescription">
                3. т больше, чем д. На этом сравнение заканчивается. Первая
                строка больше.
              </p>

              <p class="form__attention">
                Используется кодировка Unicode, а не настоящий алфавит
              </p>

              <p class="form__description">
                Приведённый выше алгоритм сравнения похож на алгоритм,
                используемый в словарях и телефонных книгах, но между ними есть
                и различия.
              </p>

              <p class="form__description">
                Например, в JavaScript имеет значение регистр символов.
                Заглавная буква "A" не равна строчной "a". Какая же из них
                больше? Строчная "a". Почему? Потому что строчные буквы имеют
                больший код во внутренней таблице кодирования, которую
                использует JavaScript (Unicode). Мы ещё поговорим о внутреннем
                представлении строк и его влиянии в главе Строки.
              </p>

              <p class="form__subheading">
                <a
                  target="_blank"
                  rel="noopener"
                  href="https://learn.javascript.ru/comparison#sravnenie-raznyh-tipov"
                  class="form__link"
                >
                  Сравнение разных типов</a
                >
              </p>

              <p class="form__description">
                При сравнении значений разных типов JavaScript приводит каждое
                из них к числу. Например:
              </p>

              <p class="form__subdescription">
                alert( '2' > 1 ); // true, строка '2' становится числом 2 <br />
                alert( '01' == 1 ); // true, строка '01' становится числом 1
              </p>

              <p class="form__description">
                Логическое значение true становится 1, а false – 0. Например:
              </p>

              <p class="form__subdescription">
                alert( true == 1 ); // true <br />
                alert( false == 0 ); // true
              </p>

              <p class="form__attention">Забавное следствие</p>

              <p class="form__description">Возможна следующая ситуация:</p>

              <p class="form__subdescription">Два значения равны.</p>

              <p class="form__subdescription">
                Одно из них true как логическое значение, другое – false.
              </p>

              <p class="form__subdescription">
                let a = 0; <br />
                alert( Boolean(a) ); // false <br />
                <br />
                let b = "0"; <br />
                alert( Boolean(b) ); // true <br />
                <br />
                alert(a == b); // true!
              </p>

              <p class="form__description">
                С точки зрения JavaScript, результат ожидаем. Равенство
                преобразует значения, используя числовое преобразование, поэтому
                "0" становится 0. В то время как явное преобразование с помощью
                Boolean использует другой набор правил.
              </p>

              <p class="form__subheading">
                <a
                  target="_blank"
                  rel="noopener"
                  href="https://learn.javascript.ru/comparison#strogoe-sravnenie"
                  class="form__link"
                >
                  Строгое сравнение</a
                >
              </p>

              <p class="form__description">
                Использование обычного сравнения == может вызывать проблемы.
                Например, оно не отличает 0 от false:
              </p>

              <p class="form__subdescription">alert( 0 == false ); // true</p>

              <p class="form__description">Та же проблема с пустой строкой:</p>

              <p class="form__subdescription">alert( '' == false ); // true</p>

              <p class="form__description">
                Это происходит из-за того, что операнды разных типов
                преобразуются оператором == к числу. В итоге, и пустая строка, и
                false становятся нулём.
              </p>

              <p class="form__description">Как же тогда отличать 0 от false?</p>

              <p class="form__attention">
                Оператор строгого равенства === проверяет равенство без
                приведения типов.
              </p>

              <p class="form__description">
                Другими словами, если a и b имеют разные типы, то проверка a ===
                b немедленно возвращает false без попытки их преобразования.
              </p>

              <p class="form__subdescription">
                alert( 0 === false ); // false, так как сравниваются разные типы
              </p>

              <p class="form__description">
                Ещё есть оператор строгого неравенства !==, аналогичный !=.
              </p>

              <p class="form__description">
                Оператор строгого равенства дольше писать, но он делает код
                более очевидным и оставляет меньше места для ошибок.
              </p>

              <p class="form__subheading">
                <a
                  target="_blank"
                  rel="noopener"
                  href="https://learn.javascript.ru/comparison#sravnenie-s-null-i-undefined"
                  class="form__link"
                >
                  Сравнение с null и undefined</a
                >
              </p>

              <p class="form__description">
                Поведение null и undefined при сравнении с другими значениями —
                особое:
              </p>

              <p class="form__attention">При строгом равенстве ===</p>

              <p class="form__description">
                Эти значения различны, так как различны их типы.
              </p>

              <p class="form__subdescription">
                alert( null === undefined ); // false
              </p>

              <p class="form__attention">При нестрогом равенстве ==</p>

              <p class="form__description">
                Эти значения равны друг другу и не равны никаким другим
                значениям. Это специальное правило языка.
              </p>

              <p class="form__subdescription">
                alert( null == undefined ); // true
              </p>

              <p class="form__attention">
                При использовании математических операторов и других операторов
                сравнения &lt; &gt; &lt;= &gt;=
              </p>

              <p class="form__description">
                Значения null/undefined преобразуются к числам: null становится
                0, а undefined – NaN.
              </p>

              <p class="form__description">
                Посмотрим, какие забавные вещи случаются, когда мы применяем эти
                правила. И, что более важно, как избежать ошибок при их
                использовании.
              </p>

              <p class="form__attention">
                Странный результат сравнения null и 0
              </p>

              <p class="form__description">Сравним null с нулём:</p>

              <p class="form__subdescription">
                alert( null > 0 ); // (1) false <br />
                alert( null == 0 ); // (2) false <br />
                alert( null >= 0 ); // (3) true
              </p>

              <p class="form__description">
                С точки зрения математики это странно. Результат последнего
                сравнения говорит о том, что "null больше или равно нулю", тогда
                результат одного из сравнений выше должен быть true, но они оба
                ложны.
              </p>

              <p class="form__description">
                Причина в том, что нестрогое равенство и сравнения &gt; &lt;
                &gt;= &lt;= работают по-разному. Сравнения преобразуют null в
                число, рассматривая его как 0. Поэтому выражение (3) null >= 0
                истинно, а null > 0 ложно.
              </p>

              <p class="form__description">
                С другой стороны, для нестрогого равенства == значений undefined
                и null действует особое правило: эти значения ни к чему не
                приводятся, они равны друг другу и не равны ничему другому.
                Поэтому (2) null == 0 ложно.
              </p>

              <p class="form__subheading">
                <a
                  target="_blank"
                  rel="noopener"
                  href="https://learn.javascript.ru/comparison#nesravnennoe-znachenie-undefined"
                  class="form__link"
                >
                  Несравненное значение undefined</a
                >
              </p>

              <p class="form__description">
                Значение undefined несравнимо с другими значениями:
              </p>

              <p class="form__subdescription">
                alert( undefined > 0 ); // false (1) <br />
                alert( undefined &lt; 0 ); // false (2) <br />
                alert( undefined == 0 ); // false (3)
              </p>

              <p class="form__description">
                Почему же сравнение undefined с нулём всегда ложно? На это есть
                следующие причины:
              </p>

              <p class="form__subdescription">
                Сравнения (1) и (2) возвращают false, потому что undefined
                преобразуется в NaN, а NaN – это специальное числовое значение,
                которое возвращает false при любых сравнениях.
              </p>

              <p class="form__subdescription">
                Нестрогое равенство (3) возвращает false, потому что undefined
                равно только null, undefined и ничему больше.
              </p>

              <p class="form__subheading">
                <a
                  target="_blank"
                  rel="noopener"
                  href="https://learn.javascript.ru/comparison#kak-izbezhat-problem"
                  class="form__link"
                >
                  Как избежать проблем</a
                >
              </p>

              <p class="form__description">
                Зачем мы рассмотрели все эти примеры? Должны ли мы постоянно
                помнить обо всех этих особенностях? Не обязательно. Со временем
                все они станут вам знакомы, но можно избежать проблем, если
                следовать надёжным правилам:
              </p>

              <p class="form__subdescription">
                Относитесь очень осторожно к любому сравнению с undefined/null,
                кроме случаев строгого равенства ===.
              </p>

              <p class="form__subdescription">
                Не используйте сравнения &gt;= &gt; &lt; &lt;= с переменными,
                которые могут принимать значения null/undefined, разве что вы
                полностью уверены в том, что делаете. Если переменная может
                принимать эти значения, то добавьте для них отдельные проверки.
              </p>

              <p class="form__subheading">
                <a
                  target="_blank"
                  rel="noopener"
                  href="https://learn.javascript.ru/comparison#itogo"
                  class="form__link"
                >
                  Итого</a
                >
              </p>

              <p class="form__subdescription">
                Операторы сравнения возвращают значения логического типа.
              </p>

              <p class="form__subdescription">
                Строки сравниваются посимвольно в лексикографическом порядке.
              </p>

              <p class="form__subdescription">
                Значения разных типов при сравнении приводятся к числу.
                Исключением является сравнение с помощью операторов строгого
                равенства/неравенства.
              </p>

              <p class="form__subdescription">
                Значения null и undefined равны == друг другу и не равны любому
                другому значению.
              </p>

              <p class="form__subdescription">
                Будьте осторожны при использовании операторов сравнений вроде >
                и &lt; с переменными, которые могут принимать значения
                null/undefined. Хорошей идеей будет сделать отдельную проверку
                на null/undefined.
              </p>

              <p class="form__subheading">
                <a
                  target="_blank"
                  rel="noopener"
                  href="https://learn.javascript.ru/comparison#tasks"
                  class="form__link"
                >
                  Задачи</a
                >
              </p>
            </div>
          </div>
          <p class="form__subheading">
            <a
              target="_blank"
              rel="noopener"
              href="https://learn.javascript.ru/comparison#tasks"
              class="form__link-tasks"
            >
              Задачи "Операторы сравнения"
            </a>
          </p>
        </section>
        <!-- Операторы сравнения -->

        <!-- Условное ветвление: if, '?' -->
        <section id="uslovnoe-vetvlenie-if-?" class="form">
          <div class="form__bloc-info">
            <h1 class="form__heading">
              <a
                target="_blank"
                rel="noopener"
                href="https://learn.javascript.ru/ifelse"
                class="form__link"
              >
                Условное ветвление: if, '?'</a
              >
            </h1>

            <div class="form__bloc-hidden">
              <p class="form__description">
                Иногда нам нужно выполнить различные действия в зависимости от
                условий. Для этого мы можем использовать инструкцию if и
                условный оператор ?, который также называют оператором
                «вопросительный знак».
              </p>

              <p class="form__subheading">
                <a
                  target="_blank"
                  rel="noopener"
                  href="https://learn.javascript.ru/ifelse#instruktsiya-if"
                  class="form__link"
                >
                  Инструкция «if»</a
                >
              </p>

              <p class="form__description">
                Инструкция if(...) вычисляет условие в скобках и, если результат
                true, то выполняет блок кода. Например:
              </p>

              <p class="form__subdescription">
                let year = prompt('В каком году была опубликована спецификация
                ECMAScript-2015?', ''); <br />

                if (year == 2015) alert( 'Вы правы!' );
              </p>

              <p class="form__description">
                В примере выше, условие – это простая проверка на равенство
                (year == 2015), но оно может быть и гораздо более сложным.
              </p>

              <p class="form__description">
                Если мы хотим выполнить более одной инструкции, то нужно
                заключить блок кода в фигурные скобки:
              </p>

              <p class="form__subdescription">
                if (year == 2015) { <br />
                alert( "Правильно!" ); <br />
                alert( "Вы такой умный!" );<br />
                }
              </p>

              <p class="form__description">
                Мы рекомендуем использовать фигурные скобки {} всегда, когда вы
                используете инструкцию if, даже если выполняется только одна
                команда. Это улучшает читабельность кода.
              </p>

              <p class="form__subheading">
                <a
                  target="_blank"
                  rel="noopener"
                  href="https://learn.javascript.ru/ifelse#preobrazovanie-k-logicheskomu-tipu"
                  class="form__link"
                >
                  Преобразование к логическому типу</a
                >
              </p>

              <p class="form__description">
                Инструкция if (…) вычисляет выражение в скобках и преобразует
                результат к логическому типу.
              </p>

              <p class="form__description">
                Давайте вспомним правила преобразования типов из главы
                Преобразование типов:
              </p>

              <p class="form__attention">
                Число 0, пустая строка "", null, undefined и NaN становятся
                false. Из-за этого их называют «ложными» («falsy») значениями.
              </p>

              <p class="form__attention">
                Остальные значения становятся true, поэтому их называют
                «правдивыми» («truthy»).
              </p>

              <p class="form__description">
                Таким образом, код при таком условии никогда не выполнится:
              </p>

              <p class="form__subdescription">
                if (0) { // 0 is falsy <br />
                ... <br />
                }
              </p>

              <p class="form__description">…а при таком – выполнится всегда:</p>

              <p class="form__subdescription">
                if (1) { // 1 is truthy <br />
                ... <br />
                }
              </p>

              <p class="form__description">
                Мы также можем передать заранее вычисленное в переменной
                логическое значение в if, например так:
              </p>

              <p class="form__subdescription">
                let condition = (year == 2015); // преобразуется к true или
                false <br />

                if (condition) {<br />
                ...<br />
                }
              </p>

              <p class="form__subheading">
                <a
                  target="_blank"
                  rel="noopener"
                  href="https://learn.javascript.ru/ifelse#blok-else"
                  class="form__link"
                >
                  Блок «else»</a
                >
              </p>

              <p class="form__description">
                Инструкция if может содержать необязательный блок «else»
                («иначе»). Он выполняется, когда условие ложно. Например:
              </p>

              <p class="form__subdescription">
                let year = prompt('В каком году была опубликована спецификация
                ECMAScript-2015?', ''); <br />

                if (year == 2015) { <br />
                alert( 'Да вы знаток!' ); <br />
                } else { <br />
                alert( 'А вот и неправильно!' ); // любое значение, кроме 2015
                <br />
                }
              </p>

              <p class="form__subheading">
                <a
                  target="_blank"
                  rel="noopener"
                  href="https://learn.javascript.ru/ifelse#neskolko-usloviy-else-if"
                  class="form__link"
                >
                  Несколько условий: «else if»</a
                >
              </p>

              <p class="form__description">
                Иногда, нужно проверить несколько вариантов условия. Для этого
                используется блок else if. Например:
              </p>

              <p class="form__subdescription">
                let year = prompt('В каком году была опубликована спецификация
                ECMAScript-2015?', ''); <br />

                if (year &lt; 2015) { <br />
                alert( 'Это слишком рано...' ); <br />
                } else if (year > 2015) { <br />
                alert( 'Это поздновато' ); <br />
                } else { <br />
                alert( 'Верно!' ); <br />
                }
              </p>

              <p class="form__description">
                В приведённом выше коде JavaScript сначала проверит year &lt;
                2015. Если это неверно, он переходит к следующему условию year >
                2015. Если оно тоже ложно, тогда сработает последний alert.
              </p>

              <p class="form__description">
                Блоков else if может быть и больше. Присутствие блока else не
                является обязательным.
              </p>

              <p class="form__subheading">
                <a
                  target="_blank"
                  rel="noopener"
                  href="https://learn.javascript.ru/ifelse#uslovnyy-operator"
                  class="form__link"
                >
                  Условный оператор „?“</a
                >
              </p>

              <p class="form__description">
                Иногда нам нужно определить переменную в зависимости от условия.
                Например:
              </p>

              <p class="form__subdescription">
                let accessAllowed;<br />
                let age = prompt('Сколько вам лет?', ''); <br />

                if (age > 18) { <br />
                accessAllowed = true; <br />
                } else { <br />
                accessAllowed = false; <br />
                } <br />

                alert(accessAllowed);
              </p>

              <p class="form__description">
                Так называемый «условный» оператор «вопросительный знак»
                позволяет нам сделать это более коротким и простым способом.
              </p>

              <p class="form__description">
                Оператор представлен знаком вопроса ?. Его также называют
                «тернарный», так как этот оператор, единственный в своём роде,
                имеет три аргумента.
              </p>

              <p class="form__description">Синтаксис:</p>

              <p class="form__syntax">
                let result = условие ? значение1 : значение2;
              </p>

              <p class="form__description">
                Сначала вычисляется условие: если оно истинно, тогда
                возвращается значение1, в противном случае – значение2.
                Например:
              </p>

              <p class="form__subdescription">
                let accessAllowed = (age > 18) ? true : false;
              </p>

              <p class="form__description">
                Технически, мы можем опустить круглые скобки вокруг age > 18.
                Оператор вопросительного знака имеет низкий приоритет, поэтому
                он выполняется после сравнения >.
              </p>

              <p class="form__description">
                Этот пример будет делать то же самое, что и предыдущий:
              </p>

              <p class="form__subdescription">
                // оператор сравнения "age > 18" выполняется первым в любом
                случае <br />
                // (нет необходимости заключать его в скобки) <br />
                let accessAllowed = age > 18 ? true : false;
              </p>

              <p class="form__description">
                Но скобки делают код более читабельным, поэтому мы рекомендуем
                их использовать.
              </p>

              <p class="form__attention">На заметку:</p>

              <p class="form__description">
                В примере выше вы можете избежать использования оператора
                вопросительного знака ?, т.к. сравнение само по себе уже
                возвращает true/false:
              </p>

              <p class="form__subdescription">
                // то же самое let accessAllowed = age > 18;
              </p>

              <p class="form__subheading">
                <a
                  target="_blank"
                  rel="noopener"
                  href="https://learn.javascript.ru/ifelse#neskolko-operatorov"
                  class="form__link"
                >
                  Несколько операторов „?“</a
                >
              </p>

              <p class="form__description">
                Последовательность операторов вопросительного знака ? позволяет
                вернуть значение, которое зависит от более чем одного условия.
                Например:
              </p>

              <p class="form__subdescription">
                let age = prompt('Возраст?', 18); <br />
                <br />
                let message = (age &lt; 3) ? 'Здравствуй, малыш!' : <br />
                (age &lt; 18) ? 'Привет!' : <br />
                (age &lt; 100) ? 'Здравствуйте!' : <br />
                'Какой необычный возраст!'; <br />
                <br />
                alert( message );
              </p>

              <p class="form__description">
                Поначалу может быть сложно понять, что происходит. Но при
                ближайшем рассмотрении мы видим, что это обычная
                последовательная проверка:
              </p>

              <p class="form__subdescription">
                1. Первый знак вопроса проверяет age &lt; 3.
              </p>

              <p class="form__subdescription">
                2. Если верно – возвращает 'Здравствуй, малыш!'. В противном
                случае, проверяет выражение после двоеточия „":"“, вычисляет age
                &lt; 18.
              </p>

              <p class="form__subdescription">
                3. Если это верно – возвращает 'Привет!'. В противном случае,
                проверяет выражение после следующего двоеточия „":"“, вычисляет
                age &lt; 100.
              </p>

              <p class="form__subdescription">
                4. Если это верно – возвращает 'Здравствуйте!'. В противном
                случае, возвращает выражение после последнего двоеточия – 'Какой
                необычный возраст!'.
              </p>

              <p class="form__description">
                Вот как это выглядит при использовании if..else:
              </p>

              <p class="form__subdescription">
                if (age &lt; 3) { <br />
                message = 'Здравствуй, малыш!'; <br />
                } else if (age &lt; 18) { <br />
                message = 'Привет!'; <br />
                } else if (age &lt; 100) { <br />
                message = 'Здравствуйте!'; <br />
                } else { <br />
                message = 'Какой необычный возраст!'; <br />
                }
              </p>

              <p class="form__subheading">
                <a
                  target="_blank"
                  rel="noopener"
                  href="https://learn.javascript.ru/ifelse#neskolko-operatorov"
                  class="form__link"
                >
                  Нетрадиционное использование „?“</a
                >
              </p>

              <p class="form__description">
                Иногда оператор «вопросительный знак» ? используется в качестве
                замены if:
              </p>

              <p class="form__subdescription">
                let company = prompt('Какая компания создала JavaScript?', '');
                <br />
                <br />
                (company == 'Netscape') ? <br />
                alert('Верно!') : alert('Неправильно.');
              </p>

              <p class="form__description">
                В зависимости от условия company == 'Netscape', будет выполнена
                либо первая, либо вторая часть после ?.
              </p>

              <p class="form__description">
                Здесь мы не присваиваем результат переменной. Вместо этого мы
                выполняем различный код в зависимости от условия.
              </p>

              <p class="form__attention">
                Не рекомендуется использовать оператор вопросительного знака
                таким образом.
              </p>

              <p class="form__description">
                Несмотря на то, что такая запись короче, чем эквивалентная
                инструкция if, она менее читабельна. Вот, для сравнения, тот же
                код, использующий if:
              </p>

              <p class="form__subdescription">
                let company = prompt('Какая компания создала JavaScript?', '');
                <br />
                <br />
                if (company == 'Netscape') { <br />
                alert('Верно!'); <br />
                } else { <br />
                alert('Неправильно.'); <br />
                }
              </p>

              <p class="form__description">
                При чтении глаза сканируют код по вертикали. Блоки кода,
                занимающие несколько строк, воспринимаются гораздо легче, чем
                длинный горизонтальный набор инструкций.
              </p>

              <p class="form__description">
                Смысл оператора «вопросительный знак» ? – вернуть то или иное
                значение, в зависимости от условия. Пожалуйста, используйте его
                именно для этого. Когда вам нужно выполнить разные ветви кода –
                используйте if.
              </p>

              <p class="form__subheading">
                <a
                  target="_blank"
                  rel="noopener"
                  href="https://learn.javascript.ru/ifelse#tasks"
                  class="form__link"
                >
                  Задачи</a
                >
              </p>
            </div>
          </div>
          <p class="form__subheading">
            <a
              target="_blank"
              rel="noopener"
              href="https://learn.javascript.ru/ifelse#tasks"
              class="form__link-tasks"
            >
              Задачи "Условное ветвление: if, '?'"
            </a>
          </p>
        </section>
        <!-- Условное ветвление: if, '?' -->

        <!-- Логические операторы -->
        <section id="logical-operators" class="form">
          <div class="form__bloc-info">
            <h1 class="form__heading">
              <a
                target="_blank"
                rel="noopener"
                href="https://learn.javascript.ru/logical-operators"
                class="form__link"
              >
                Логические операторы</a
              >
            </h1>
            <div class="form__bloc-hidden">
              <p class="form__description">
                В JavaScript есть три логических оператора: || (ИЛИ), && (И) и !
                (НЕ).
              </p>

              <p class="form__description">
                Несмотря на своё название, данные операторы могут применяться к
                значениям любых типов. Полученные результаты также могут иметь
                различный тип.
              </p>

              <p class="form__description">Давайте рассмотрим их подробнее.</p>

              <p class="form__subheading">
                <a
                  target="_blank"
                  rel="noopener"
                  href="https://learn.javascript.ru/logical-operators#ili"
                  class="form__link"
                >
                  || (ИЛИ)</a
                >
              </p>

              <p class="form__description">
                Оператор «ИЛИ» выглядит как двойной символ вертикальной черты:
              </p>

              <p class="form__subdescription">result = a || b;</p>

              <p class="form__description">
                Традиционно в программировании ИЛИ предназначено только для
                манипулирования булевыми значениями: в случае, если какой-либо
                из аргументов true, он вернёт true, в противоположной ситуации
                возвращается false.
              </p>

              <p class="form__description">
                В JavaScript, как мы увидим далее, этот оператор работает
                несколько иным образом. Но давайте сперва посмотрим, что
                происходит с булевыми значениями. Существует всего четыре
                возможные логические комбинации:
              </p>

              <p class="form__subdescription">
                alert( true || true ); // true <br />
                alert( false || true ); // true <br />
                alert( true || false ); // true <br />
                alert( false || false ); // false
              </p>

              <p class="form__description">
                Как мы можем наблюдать, результат операций всегда равен true, за
                исключением случая, когда оба аргумента false.
              </p>

              <p class="form__description">
                Если значение не логического типа, то оно к нему приводится в
                целях вычислений. Например, число 1 будет воспринято как true, а
                0 – как false:
              </p>

              <p class="form__subdescription">
                if (1 || 0) { // работает как if( true || false ) <br />
                alert( 'truthy!' ); <br />
                }
              </p>

              <p class="form__description">
                Обычно оператор || используется в if для проверки истинности
                любого из заданных условий. К примеру:
              </p>

              <p class="form__subdescription">
                let hour = 9; <br />
                <br />
                if (hour &lt; 10 || hour > 18) { <br />
                alert( 'Офис закрыт.' ); <br />
                }
              </p>

              <p class="form__description">Можно передать и больше условий:</p>

              <p class="form__subdescription">
                let hour = 12; <br />
                let isWeekend = true; <br />
                <br />
                if (hour &lt; 10 || hour > 18 || isWeekend) { <br />
                alert( 'Офис закрыт.' ); // это выходной <br />
                }
              </p>

              <p class="form__subheading">
                <a
                  target="_blank"
                  rel="noopener"
                  href="https://learn.javascript.ru/logical-operators#ili-nahodit-pervoe-istinnoeznachenie"
                  class="form__link"
                >
                  ИЛИ «||» находит первое истинное значение</a
                >
              </p>

              <p class="form__description">
                Описанная выше логика соответствует традиционной. Теперь давайте
                поработаем с «дополнительными» возможностями JavaScript.
              </p>

              <p class="form__description">
                Расширенный алгоритм работает следующим образом. При выполнении
                ИЛИ || с несколькими значениями:
              </p>

              <p class="form__subdescription">
                result = value1 || value2 || value3;
              </p>

              <p class="form__description">
                Оператор || выполняет следующие действия:
              </p>

              <p class="form__subdescription">
                Вычисляет операнды слева направо.
              </p>

              <p class="form__subdescription">
                Каждый операнд конвертирует в логическое значение. Если
                результат true, останавливается и возвращает исходное значение
                этого операнда.
              </p>

              <p class="form__subdescription">
                Если все операнды являются ложными (false), возвращает последний
                из них.
              </p>

              <p class="form__description">
                Значение возвращается в исходном виде, без преобразования.
              </p>

              <p class="form__description">
                Другими словами, цепочка ИЛИ "||" возвращает первое истинное
                значение или последнее, если такое значение не найдено.
                Например:
              </p>

              <p class="form__subdescription">
                alert( 1 || 0 ); // 1 <br />
                alert( true || 'no matter what' ); // true <br />
                <br />
                alert( null || 1 ); // 1 (первое истинное значение) <br />
                alert( null || 0 || 1 ); // 1 (первое истинное значение) <br />
                al
              </p>

              <p class="form__description">
                Это делает возможным более интересное применение оператора по
                сравнению с «чистым, традиционным, только булевым ИЛИ».
              </p>

              <p class="form__attention">
                1. Получение первого истинного значения из списка переменных или
                выражений.
              </p>

              <p class="form__description">
                Представим, что у нас имеется ряд переменных, которые могут
                содержать данные или быть null/undefined. Как мы можем найти
                первую переменную с данными? С помощью ||:
              </p>

              <p class="form__subdescription">
                let currentUser = null; <br />
                let defaultUser = "John"; <br />
                <br />
                let name = currentUser || defaultUser || "unnamed"; <br />
                <br />
                alert( name ); // выбирается "John" – первое истинное значение
              </p>

              <p class="form__description">
                Если бы и currentUser, и defaultUser были ложными, в качестве
                результата мы бы наблюдали "unnamed".
              </p>

              <p class="form__attention">2. Сокращённое вычисление.</p>

              <p class="form__description">
                Операндами могут быть как отдельные значения, так и произвольные
                выражения. ИЛИ вычисляет их слева направо. Вычисление
                останавливается при достижении первого истинного значения. Этот
                процесс называется «сокращённым вычислением», поскольку второй
                операнд вычисляется только в том случае, если первого
                недостаточно для вычисления всего выражения.
              </p>

              <p class="form__description">
                Это хорошо заметно, когда выражение, указанное в качестве
                второго аргумента, имеет побочный эффект, например, изменение
                переменной. В приведённом ниже примере x не изменяется:
              </p>

              <p class="form__subdescription">
                let x; <br />
                <br />
                true || (x = 1); <br />
                <br />
                alert(x); // undefined, потому что вычисление останавливается на
                true и (x = 1) не вычисляется.
              </p>

              <p class="form__description">
                Если бы первый аргумент имел значение false, то || приступил бы
                к вычислению второго и выполнил операцию присваивания:
              </p>

              <p class="form__subdescription">
                let x <br />
                <br />
                false || (x = 1); <br />
                <br />
                alert(x); // 1
              </p>

              <p class="form__description">
                Присваивание – лишь один пример. Конечно, могут быть и другие
                побочные эффекты, которые не проявятся, если вычисление до них
                не дойдёт.
              </p>

              <p class="form__description">
                Как мы видим, этот вариант использования || является "аналогом
                if". Первый операнд преобразуется в логический. Если он
                оказывается ложным, начинается вычисление второго.
              </p>

              <p class="form__description">
                В большинстве случаев лучше использовать «обычный» if, чтобы
                облегчить понимание кода, но иногда это может быть удобно.
              </p>

              <p class="form__subheading">
                <a
                  target="_blank"
                  rel="noopener"
                  href="https://learn.javascript.ru/logical-operators#i"
                  class="form__link"
                >
                  && (И)</a
                >
              </p>

              <p class="form__description">
                Оператор И пишется как два амперсанда &&:
              </p>

              <p class="form__subdescription">result = a && b;</p>

              <p class="form__description">
                В традиционном программировании И возвращает true, если оба
                аргумента истинны, а иначе – false:
              </p>

              <p class="form__subdescription">
                alert( true && true ); // true <br />
                alert( false && true ); // false <br />
                alert( true && false ); // false <br />
                alert( false && false ); // false
              </p>

              <p class="form__description">Пример с if:</p>

              <p class="form__subdescription">
                let hour = 12; <br />
                let minute = 30; <br />
                <br />
                if (hour == 12 && minute == 30) { <br />
                alert( 'The time is 12:30' ); <br />
                }
              </p>

              <p class="form__description">
                Как и в случае с ИЛИ, любое значение допускается в качестве
                операнда И:
              </p>

              <p class="form__subdescription">
                if (1 && 0) { // вычисляется как true && false <br />
                alert( "не сработает, так как результат ложный" ); }
              </p>

              <p class="form__subheading">
                <a
                  target="_blank"
                  rel="noopener"
                  href="https://learn.javascript.ru/logical-operators#i-nahodit-pervoe-lozhnoeznachenie"
                  class="form__link"
                >
                  И «&&» находит первое ложное значение</a
                >
              </p>

              <p class="form__description">
                При нескольких подряд операторах И:
              </p>

              <p class="form__subdescription">
                result = value1 && value2 && value3;
              </p>

              <p class="form__description">
                Оператор && выполняет следующие действия:
              </p>

              <p class="form__subdescription">
                Вычисляет операнды слева направо.
              </p>

              <p class="form__subdescription">
                Каждый операнд преобразует в логическое значение. Если результат
                false, останавливается и возвращает исходное значение этого
                операнда.
              </p>

              <p class="form__subdescription">
                Если все операнды были истинными, возвращается последний.
              </p>

              <p class="form__description">
                Другими словами, И возвращает первое ложное значение. Или
                последнее значение, если ничего не найдено.
              </p>

              <p class="form__description">
                Вышеуказанные правила схожи с поведением ИЛИ. Разница в том, что
                И возвращает первое ложное значение, а ИЛИ –  первое истинное.
                Примеры:
              </p>

              <p class="form__subdescription">
                // Если первый операнд истинный, <br />
                // И возвращает второй: <br />
                alert( 1 && 0 ); // 0 <br />
                alert( 1 && 5 ); // 5 <br />
                <br />
                // Если первый операнд ложный, <br />
                // И возвращает его. Второй операнд игнорируется <br />
                alert( null && 5 ); // null <br />
                alert( 0 && "no matter what" ); // 0
              </p>

              <p class="form__description">
                Можно передать несколько значений подряд. В таком случае
                возвратится первое «ложное» значение, на котором остановились
                вычисления.
              </p>

              <p class="form__subdescription">
                alert( 1 && 2 && null && 3 ); // null
              </p>

              <p class="form__description">
                Когда все значения верны, возвращается последнее
              </p>

              <p class="form__subdescription">alert( 1 && 2 && 3 ); // 3</p>

              <p class="form__attention">
                Приоритет оператора && больше, чем у ||
              </p>

              <p class="form__description">
                Приоритет оператора И && больше, чем ИЛИ ||, так что он
                выполняется раньше.
              </p>

              <p class="form__description">
                Приоритет оператора И && больше, чем ИЛИ ||, так что он
                выполняется раньше.
              </p>

              <p class="form__description">
                Таким образом, код a && b || c && d по существу такой же, как
                если бы выражения && были в круглых скобках: (a && b) || (c &&
                d).
              </p>

              <p class="form__description">
                Как и оператор ИЛИ, И && иногда может заменять if. К примеру:
              </p>

              <p class="form__subdescription">
                let x = 1; <br />

                (x > 0) && alert( 'Greater than zero!' );
              </p>

              <p class="form__description">
                Действие в правой части && выполнится только в том случае, если
                до него дойдут вычисления. То есть, alert сработает, если в
                левой части (x > 0) будет true. Получился аналог:
              </p>

              <p class="form__subdescription">
                let x = 1; <br />
                <br />
                if (x > 0) { <br />
                alert( 'Greater than zero!' ); <br />
                }
              </p>

              <p class="form__description">
                Однако, как правило, вариант с if лучше читается и
                воспринимается. Он более очевиден, поэтому лучше использовать
                его.
              </p>

              <p class="form__subheading">
                <a
                  target="_blank"
                  rel="noopener"
                  href="https://learn.javascript.ru/logical-operators#ne"
                  class="form__link"
                >
                  ! (НЕ)</a
                >
              </p>

              <p class="form__description">
                Оператор НЕ представлен восклицательным знаком !. Синтаксис
                довольно прост:
              </p>

              <p class="form__subdescription">result = !value;</p>

              <p class="form__description">
                Оператор принимает один аргумент и выполняет следующие действия:
              </p>

              <p class="form__subdescription">
                1. Сначала приводит аргумент к логическому типу true/false.
              </p>

              <p class="form__subdescription">
                2. Затем возвращает противоположное значение.
              </p>

              <p class="form__description">Например:</p>

              <p class="form__subdescription">
                alert( !true ); // false <br />
                alert( !0 ); // true
              </p>

              <p class="form__description">
                В частности, двойное НЕ используют для преобразования значений к
                логическому типу:
              </p>

              <p class="form__subdescription">
                alert( !!"non-empty string" ); // true <br />
                alert( !!null ); // false
              </p>

              <p class="form__description">
                То есть первое НЕ преобразует значение в логическое значение и
                возвращает обратное, а второе НЕ снова инвертирует его. В конце
                мы имеем простое преобразование значения в логическое.
              </p>

              <p class="form__description">
                Есть немного более подробный способ сделать то же самое –
                встроенная функция Boolean:
              </p>

              <p class="form__subdescription">
                alert( Boolean("non-empty string") ); // true <br />
                alert( Boolean(null) ); // false
              </p>

              <p class="form__description">
                Приоритет НЕ ! является наивысшим из всех логических операторов,
                поэтому он всегда выполняется первым, перед && или ||.
              </p>

              <p class="form__subheading">
                <a
                  target="_blank"
                  rel="noopener"
                  href="https://learn.javascript.ru/nullish-coalescing-operator"
                  class="form__link"
                >
                  Оператор объединения с null '??'</a
                >
              </p>

              <p class="form__attention">Новая возможность</p>

              <p class="form__description">
                Эта возможность была добавлена в язык недавно. В старых
                браузерах может понадобиться полифил.
              </p>

              <p class="form__description">
                Оператор объединения с null представляет собой два
                вопросительных знака ??.
              </p>

              <p class="form__description">
                Результат выражения a ?? b будет следующим:
              </p>

              <p class="form__subdescription">a, если значение a определено,</p>

              <p class="form__subdescription">
                b, если значение a не определено.
              </p>

              <p class="form__description">
                То есть оператор ?? возвращает первый аргумент, если он не
                null/undefined, иначе второй.
              </p>

              <p class="form__description">
                Оператор объединения с null не является чем-то принципиально
                новым. Это всего лишь удобный синтаксис, как из двух значений
                получить одно «определённое».
              </p>

              <p class="form__subdescription">
                Вот как можно переписать выражение result = a ?? b, используя
                уже знакомые нам операторы:
              </p>

              <p class="form__subdescription">
                result = (a !== null && a !== undefined) ? a : b;
              </p>

              <p class="form__description">
                Как правило, оператор ?? нужен для того, чтобы задать значение
                по умолчанию для потенциально неопределённой переменной.
              </p>

              <p class="form__description">
                Например, в следующем примере, если переменная user не
                определена, покажем модальное окно с надписью Аноним:
              </p>

              <p class="form__subdescription">
                let user; <br />
                <br />
                alert(user ?? "Аноним"); // Аноним
              </p>

              <p class="form__description">
                Конечно, если бы переменная user содержала любое значение, кроме
                null/undefined, то мы бы увидели его:
              </p>

              <p class="form__subdescription">
                let user = "Иван"; <br />
                <br />

                alert(user ?? "Аноним"); // Иван
              </p>

              <p class="form__description">
                Кроме этого, можно записать последовательность из операторов ??,
                чтобы получить первое значение из списка, которое не является
                null/undefined.
              </p>

              <p class="form__description">
                Допустим, у нас есть данные пользователя в переменных firstName,
                lastName или nickName. Все они могут быть неопределёнными, если
                отсутствует соответствующая информация.
              </p>

              <p class="form__description">
                Выведем имя пользователя, используя одну из этих переменных, а в
                случае если все они не определены, то покажем «Аноним».
              </p>

              <p class="form__description">
                Для этого воспользуемся оператором ??:
              </p>

              <p class="form__subdescription">
                let firstName = null; <br />
                let lastName = null; <br />
                let nickName = "Суперкодер"; <br />
                <br />
                // показывает первое определённое значение: <br />
                alert(firstName ?? lastName ?? nickName ?? "Аноним"); //
                Суперкодер
              </p>

              <p class="form__subheading">
                <a
                  target="_blank"
                  rel="noopener"
                  href="https://learn.javascript.ru/nullish-coalescing-operator#sravnenie-s"
                  class="form__link"
                >
                  Сравнение с ||</a
                >
              </p>

              <p class="form__description">
                Оператор ИЛИ || можно использовать для того же, что и ??, как
                это было показано в предыдущей главе.
              </p>

              <p class="form__description">
                Например, если в приведённом выше коде заменить ?? на ||, то
                будет тот же самый результат:
              </p>

              <p class="form__subdescription">
                let firstName = null; <br />
                let lastName = null; <br />
                let nickName = "Суперкодер"; <br />
                <br />

                // показывает первое истинное значение: <br />
                alert(firstName || lastName || nickName || "Аноним"); //
                Суперкодер
              </p>

              <p class="form__description">
                Оператор ИЛИ || существует с самого появления JavaScript,
                поэтому ранее для решения похожих задач разработчики
                использовали именно его.
              </p>

              <p class="form__description">
                С другой стороны, сравнительно недавно в язык был добавлен
                оператор объединения с null ?? как раз потому, что многие были
                недовольны оператором ||.
              </p>

              <p class="form__description">
                Важное различие между ними заключается в том, что:
              </p>

              <p class="form__subdescription">
                || возвращает первое истинное значение.
              </p>

              <p class="form__subdescription">
                ?? возвращает первое определённое значение.
              </p>

              <p class="form__description">
                Проще говоря, оператор || не различает false, 0, пустую строку
                "" и null/undefined. Для него они все одинаковые, т.е. являются
                ложными значениями. Если первым аргументом для оператора ||
                будет любое из перечисленных значений, то в качестве результата
                мы получим второй аргумент.
              </p>

              <p class="form__description">
                Однако на практике часто требуется использовать значение по
                умолчанию только тогда, когда переменная является
                null/undefined. Ведь именно тогда значение действительно
                неизвестно/не определено.
              </p>

              <p class="form__description">
                Например, рассмотрим следующий пример:
              </p>

              <p class="form__subdescription">
                let height = 0; <br />
                <br />
                alert(height || 100); // 100 <br />
                alert(height ?? 100); // 0
              </p>

              <p class="form__subdescription">
                height || 100 проверяет, имеет ли переменная height ложное
                значение, что так и есть, <br />
                поэтому результатом является второй аргумент, т.е. 100.
              </p>

              <p class="form__subdescription">
                height ?? 100 проверяет, что переменная height содержит
                null/undefined, а поскольку это не так, <br />
                то результатом является сама переменная height, т.е. 0.
              </p>

              <p class="form__description">
                Если нулевая высота является «нормальным» значением, которое не
                должно заменяться значением по умолчанию, то оператор ?? делает
                как раз то, что нужно.
              </p>

              <p class="form__subheading">
                <a
                  target="_blank"
                  rel="noopener"
                  href="https://learn.javascript.ru/nullish-coalescing-operator#prioritet"
                  class="form__link"
                >
                  Приоритет</a
                >
              </p>

              <p class="form__description">
                Оператор ?? имеет довольно низкий приоритет: 5, согласно таблице
                на MDN. Таким образом, оператор ?? вычисляется до = и ?, но
                после большинства других операций, таких как +, *.
              </p>

              <p class="form__description">
                Из этого следует, что если нужно выбрать значение при помощи
                оператора ?? вместе с другими операторами в выражении, следует
                добавить круглые скобки:
              </p>

              <p class="form__subdescription">
                let height = null; <br />
                let width = null; <br />
                <br />
                // важно: используйте круглые скобки <br />
                let area = (height ?? 100) * (width ?? 50); <br />
                <br />
                alert(area); // 5000
              </p>

              <p class="form__description">
                Иначе, если опустить скобки, то оператор * выполнится первым,
                так как у него приоритет выше, чем у ??, а это приведёт к
                неправильным результатам.
              </p>

              <p class="form__subdescription">
                // без круглых скобок <br />
                let area = height ?? 100 * width ?? 50; <br />
                <br />
                // ...то же самое, что предыдущее выражение (вероятно, это не
                то, что нам нужно): <br />
                let area = height ?? (100 * width) ?? 50;
              </p>

              <p class="form__subheading">
                <a
                  target="_blank"
                  rel="noopener"
                  href="https://learn.javascript.ru/nullish-coalescing-operator#ispolzovanie-vmeste-s-ili"
                  class="form__link"
                >
                  Использование ?? вместе с && или ||</a
                >
              </p>

              <p class="form__description">
                По соображениям безопасности JavaScript запрещает использование
                оператора ?? вместе с && и ||, если только приоритет явно не
                указан в круглых скобках.
              </p>

              <p class="form__description">
                Выполнение следующего кода приведёт к синтаксической ошибке:
              </p>

              <p class="form__subdescription">
                let x = 1 && 2 ?? 3; // Синтаксическая ошибкаx
              </p>

              <p class="form__description">
                Это довольно спорное ограничение, которое было описано в
                спецификации языка, чтобы избежать ошибок при замене оператора
                || на ??.
              </p>

              <p class="form__description">
                Используйте круглые скобки, чтобы обойти это ограничение:
              </p>

              <p class="form__subdescription">
                let x = (1 && 2) ?? 3; // Работает без ошибок <br />
                <br />
                alert(x); // 2
              </p>

              <p class="form__subheading">
                <a
                  target="_blank"
                  rel="noopener"
                  href="https://learn.javascript.ru/nullish-coalescing-operator#itogo"
                  class="form__link"
                >
                  Итого</a
                >
              </p>

              <p class="form__subdescription">
                Оператор объединения с null ?? — это быстрый способ выбрать
                первое «определённое» значение из списка.
              </p>

              <p class="form__description">
                Используется для присвоения переменным значений по умолчанию:
              </p>

              <p class="form__subdescription">
                // будет height=100, если переменная height равна null или
                undefined <br />
                height = height ?? 100;
              </p>

              <p class="form__subdescription">
                Оператор ?? имеет очень низкий приоритет, лишь немного выше, чем
                у ? и =, поэтому при использовании его в выражении, скорее
                всего, потребуются скобки.
              </p>

              <p class="form__subdescription">
                Запрещено использовать вместе с || или && без явно указанных
                круглых скобок.
              </p>
            </div>
          </div>
          <p class="form__subheading">
            <a
              target="_blank"
              rel="noopener"
              href="https://learn.javascript.ru/logical-operators#tasks"
              class="form__link-tasks"
            >
              Задачи "Логические операторы"
            </a>
          </p>
        </section>
        <!-- Логические операторы -->

        <!-- Циклы while и for -->
        <section id="tsikl-while-for" class="form">
          <div class="form__bloc-info">
            <h1 class="form__heading">
              Циклы
              <a
                target="_blank"
                rel="noopener"
                href="https://learn.javascript.ru/while-for"
                class="form__link"
              >
                while и for</a
              >
            </h1>
            <div class="form__bloc-hidden">
              <p class="form__description">
                При написании скриптов зачастую встаёт задача сделать однотипное
                действие много раз.
              </p>

              <p class="form__description">
                Например, вывести товары из списка один за другим. Или просто
                перебрать все числа от 1 до 10 и для каждого выполнить
                одинаковый код.
              </p>

              <p class="form__description">
                Для многократного повторения одного участка кода предусмотрены
                циклы.
              </p>

              <p class="form__subheading">
                <a
                  target="_blank"
                  rel="noopener"
                  href="https://learn.javascript.ru/while-for#tsikl-while"
                  class="form__link"
                >
                  Цикл «while»</a
                >
              </p>

              <p class="form__description">
                Цикл while имеет следующий синтаксис:
              </p>

              <p class="form__subdescription">
                while (condition) { <br />
                // код <br />
                // также называемый "телом цикла" <br />
                }
              </p>

              <p class="form__description">
                Код из тела цикла выполняется, пока условие condition истинно.
                Например, цикл ниже выводит i, пока i &lt; 3:
              </p>

              <p class="form__subdescription">
                let i = 0; <br />
                while (i &lt; 3) { // выводит 0, затем 1, затем 2 <br />
                alert( i ); <br />
                i++; <br />
                }
              </p>

              <p class="form__description">
                Одно выполнение тела цикла по-научному называется итерация. Цикл
                в примере выше совершает три итерации.
              </p>

              <p class="form__description">
                Если бы строка i++ отсутствовала в примере выше, то цикл бы
                повторялся (в теории) вечно. На практике, конечно, браузер не
                позволит такому случиться, он предоставит пользователю
                возможность остановить «подвисший» скрипт, а JavaScript на
                стороне сервера придётся «убить» процесс.
              </p>

              <p class="form__description">
                Любое выражение или переменная может быть условием цикла, а не
                только сравнение: условие while вычисляется и преобразуется в
                логическое значение.
              </p>

              <p class="form__description">
                Например, while (i) – более краткий вариант while (i != 0):
              </p>

              <p class="form__subdescription">
                let i = 3; <br />
                while (i) { // когда i будет равно 0, условие станет ложным, и
                цикл остановится <br />
                alert( i ); <br />
                i--; <br />
                }
              </p>

              <p class="form__attention">
                Фигурные скобки не требуются для тела цикла из одной строки
              </p>

              <p class="form__description">
                Если тело цикла состоит лишь из одной инструкции, мы можем
                опустить фигурные скобки {…}:
              </p>

              <p class="form__subdescription">
                let i = 3; <br />
                while (i) alert(i--);
              </p>

              <p class="form__subheading">
                <a
                  target="_blank"
                  rel="noopener"
                  href="https://learn.javascript.ru/while-for#tsikl-dowhile"
                  class="form__link"
                >
                  Цикл «do…while»</a
                >
              </p>

              <p class="form__description">
                Проверку условия можно разместить под телом цикла, используя
                специальный синтаксис do..while:
              </p>

              <p class="form__subdescription">
                do { <br />
                // тело цикла <br />
                } while (condition);
              </p>

              <p class="form__description">
                Цикл сначала выполнит тело, а затем проверит условие condition,
                и пока его значение равно true, он будет выполняться снова и
                снова. Например:
              </p>

              <p class="form__subdescription">
                let i = 0; <br />
                do { <br />
                alert( i ); <br />
                i++; <br />
                } while (i &lt; 3);
              </p>

              <p class="form__description">
                Такая форма синтаксиса оправдана, если вы хотите, чтобы тело
                цикла выполнилось хотя бы один раз, даже если условие окажется
                ложным. На практике чаще используется форма с предусловием:
                while(…) {…}.
              </p>

              <p class="form__subheading">
                <a
                  target="_blank"
                  rel="noopener"
                  href="https://learn.javascript.ru/while-for#tsikl-for"
                  class="form__link"
                >
                  Цикл «for»</a
                >
              </p>

              <p class="form__description">
                Более сложный, но при этом самый распространённый цикл — цикл
                for. Выглядит он так:
              </p>

              <p class="form__subdescription">
                for (начало; условие; шаг) { <br />
                // ... тело цикла ... <br />
                }
              </p>

              <p class="form__description">
                Давайте разберёмся, что означает каждая часть, на примере. Цикл
                ниже выполняет alert(i) для i от 0 до (но не включая) 3:
              </p>

              <p class="form__subdescription">
                for (let i = 0; i &lt; 3; i++) { // выведет 0, затем 1, затем 2
                <br />
                alert(i); <br />
                }
              </p>

              <p class="form__description">
                Рассмотрим конструкцию for подробней:
              </p>

              <p class="form__subdescription">
                начало i = 0 Выполняется один раз при входе в цикл
              </p>

              <p class="form__subdescription">
                условие i &lt; 3 Проверяется перед каждой итерацией цикла. Если
                оно вычислится в false, цикл остановится.
              </p>

              <p class="form__subdescription">
                шаг i++ Выполняется после тела цикла на каждой итерации перед
                проверкой условия.
              </p>

              <p class="form__subdescription">
                тело alert(i) Выполняется снова и снова, пока условие
                вычисляется в true.
              </p>

              <p class="form__description">
                В целом, алгоритм работы цикла выглядит следующим образом:
              </p>

              <p class="form__subdescription">Выполнить *начало*</p>

              <p class="form__subdescription">
                → (Если *условие* == true → Выполнить *тело*, Выполнить *шаг*)
              </p>

              <p class="form__subdescription">
                → (Если *условие* == true → Выполнить *тело*, Выполнить *шаг*)
              </p>

              <p class="form__subdescription">
                → (Если *условие* == true → Выполнить *тело*, Выполнить *шаг*)
              </p>

              <p class="form__subdescription">→ ...</p>

              <p class="form__description">
                То есть, начало выполняется один раз, а затем каждая итерация
                заключается в проверке условия, после которой выполняется тело и
                шаг.
              </p>

              <p class="form__description">
                Вот в точности то, что происходит в нашем случае:
              </p>

              <p class="form__subdescription">
                // for (let i = 0; i &lt; 3; i++) alert(i) <br />
                <br />
                // Выполнить начало <br />
                let i = 0; <br />
                // Если условие == true → Выполнить тело, Выполнить шаг <br />
                if (i &lt; 3) { alert(i); i++ } <br />
                // Если условие == true → Выполнить тело, Выполнить шаг <br />
                if (i &lt; 3) { alert(i); i++ } <br />
                // Если условие == true → Выполнить тело, Выполнить шаг <br />
                if (i &lt; 3) { alert(i); i++ } <br />
                // ...конец, потому что теперь i == 3
              </p>

              <p class="form__attention">Встроенное объявление переменной</p>

              <p class="form__description">
                В примере переменная счётчика i была объявлена прямо в цикле.
                Это так называемое «встроенное» объявление переменной. Такие
                переменные существуют только внутри цикла.
              </p>

              <p class="form__subdescription">
                for (let i = 0; i &lt; 3; i++) { <br />
                alert(i); // 0, 1, 2 <br />
                } <br />
                alert(i); // ошибка, нет такой переменной
              </p>

              <p class="form__description">
                Вместо объявления новой переменной мы можем использовать уже
                существующую:
              </p>

              <p class="form__subdescription">
                let i = 0; <br />
                <br />
                for (i = 0; i &lt; 3; i++) { // используем существующую
                переменную <br />
                alert(i); // 0, 1, 2 <br />
                } <br />
                <br />
                alert(i); // 3, переменная доступна, т.к. была объявлена снаружи
                цикла
              </p>

              <p class="form__subheading">
                <a
                  target="_blank"
                  rel="noopener"
                  href="https://learn.javascript.ru/while-for#propusk-chastey-for"
                  class="form__link"
                >
                  Пропуск частей «for»</a
                >
              </p>

              <p class="form__description">
                Любая часть for может быть пропущена. Для примера, мы можем
                пропустить начало если нам ничего не нужно делать перед стартом
                цикла. Вот так:
              </p>

              <p class="form__subdescription">
                let i = 0; // мы уже имеем объявленную i с присвоенным значением
                <br />
                <br />
                for (; i &lt; 3; i++) { // нет необходимости в "начале" <br />
                alert( i ); // 0, 1, 2 <br />
                }
              </p>

              <p class="form__description">Можно убрать и шаг:</p>

              <p class="form__subdescription">
                let i = 0; <br />
                <br />
                for (; i &lt; 3;) { <br />
                alert( i++ ); <br />
                }
              </p>

              <p class="form__description">
                Это сделает цикл аналогичным while (i &lt; 3). А можно и вообще
                убрать всё, получив бесконечный цикл:
              </p>

              <p class="form__subdescription">
                for (;;) { <br />
                // будет выполняться вечно <br />
                }
              </p>

              <p class="form__description">
                При этом сами точки с запятой ; обязательно должны
                присутствовать, иначе будет ошибка синтаксиса.
              </p>

              <p class="form__subheading">
                <a
                  target="_blank"
                  rel="noopener"
                  href="https://learn.javascript.ru/while-for#preryvanie-tsikla-break"
                  class="form__link"
                >
                  Прерывание цикла: «break»</a
                >
              </p>

              <p class="form__description">
                Обычно цикл завершается при вычислении условия в false. Но мы
                можем выйти из цикла в любой момент с помощью специальной
                директивы break. Например, следующий код подсчитывает сумму
                вводимых чисел до тех пор, пока посетитель их вводит, а затем –
                выдаёт:
              </p>

              <p class="form__subdescription">
                let sum = 0; <br />
                <br />
                while (true) { <br />
                <br />
                let value = +prompt("Введите число", ''); <br />
                <br />
                if (!value) break; // (*) <br />
                <br />
                sum += value; <br />
                <br />
                } <br />
                alert( 'Сумма: ' + sum );
              </p>

              <p class="form__description">
                Директива break в строке (*) полностью прекращает выполнение
                цикла и передаёт управление на строку за его телом, то есть на
                alert.
              </p>

              <p class="form__description">
                Вообще, сочетание «бесконечный цикл + break» – отличная штука
                для тех ситуаций, когда условие, по которому нужно прерваться,
                находится не в начале или конце цикла, а посередине.
              </p>

              <p class="form__subheading">
                <a
                  target="_blank"
                  rel="noopener"
                  href="https://learn.javascript.ru/while-for#continue"
                  class="form__link"
                >
                  Переход к следующей итерации: continue</a
                >
              </p>

              <p class="form__description">
                Директива continue – «облегчённая версия» break. При её
                выполнении цикл не прерывается, а переходит к следующей итерации
                (если условие все ещё равно true). Её используют, если понятно,
                что на текущем повторе цикла делать больше нечего.
              </p>

              <p class="form__description">
                Например, цикл ниже использует continue, чтобы выводить только
                нечётные значения:
              </p>

              <p class="form__subdescription">
                for (let i = 0; i &lt; 10; i++) { <br />
                <br />
                // если true, пропустить оставшуюся часть тела цикла <br />
                if (i % 2 == 0) continue; <br />
                <br />
                alert(i); // 1, затем 3, 5, 7, 9 <br />
                }
              </p>

              <p class="form__description">
                Для чётных значений i, директива continue прекращает выполнение
                тела цикла и передаёт управление на следующую итерацию for (со
                следующим числом). Таким образом alert вызывается только для
                нечётных значений.
              </p>

              <p class="form__attention">
                Директива continue позволяет избегать вложенности
              </p>

              <p class="form__description">
                Цикл, который обрабатывает только нечётные значения, мог бы
                выглядеть так:
              </p>

              <p class="form__subdescription">
                for (let i = 0; i &lt; 10; i++) { <br />
                <br />
                if (i % 2) { <br />
                alert( i ); <br />
                } <br />
                <br />
                }
              </p>

              <p class="form__description">
                С технической точки зрения он полностью идентичен.
                Действительно, вместо continue можно просто завернуть действия в
                блок if.
              </p>

              <p class="form__description">
                Однако мы получили дополнительный уровень вложенности фигурных
                скобок. Если код внутри if более длинный, то это ухудшает
                читаемость, в отличие от варианта с continue.
              </p>

              <p class="form__attention">
                Нельзя использовать break/continue справа от оператора „?“
              </p>

              <p class="form__description">
                Обратите внимание, что эти синтаксические конструкции не
                являются выражениями и не могут быть использованы с тернарным
                оператором ?. В частности, использование таких директив, как
                break/continue, вызовет ошибку. Например, если мы возьмём этот
                код:
              </p>

              <p class="form__subdescription">
                if (i > 5) { <br />
                alert(i); <br />
                } else { <br />
                continue; <br />
                }
              </p>

              <p class="form__description">
                …и перепишем его, используя вопросительный знак:
              </p>

              <p class="form__subdescription">
                (i > 5) ? alert(i) : continue; // continue здесь приведёт к
                ошибке
              </p>

              <p class="form__description">
                …то будет синтаксическая ошибка. Это ещё один повод не
                использовать оператор вопросительного знака ? вместо if.
              </p>

              <p class="form__subheading">
                <a
                  target="_blank"
                  rel="noopener"
                  href="https://learn.javascript.ru/while-for#metki-dlya-break-continue"
                  class="form__link"
                >
                  Метки для break/continue</a
                >
              </p>

              <p class="form__description">
                Бывает, нужно выйти одновременно из нескольких уровней цикла
                сразу. Например, в коде ниже мы проходимся циклами по i и j,
                запрашивая с помощью prompt координаты (i, j) с (0,0) до (2,2):
              </p>

              <p class="form__subdescription">
                for (let i = 0; i &lt; 3; i++) { <br />
                <br />
                for (let j = 0; j &lt; 3; j++) { <br />
                <br />
                let input = prompt(`Значение на координатах (${i},${j})`, '');
                <br />
                <br />
                // Что если мы захотим перейти к Готово (ниже) прямо отсюда?
                <br />
                <br />
                } <br />
                } <br />
                <br />
                alert('Готово!');
              </p>

              <p class="form__description">
                Нам нужен способ остановить выполнение если пользователь отменит
                ввод.
              </p>

              <p class="form__description">
                Обычный break после input лишь прервёт внутренний цикл, но этого
                недостаточно. Достичь желаемого поведения можно с помощью меток.
              </p>

              <p class="form__description">
                Метка имеет вид идентификатора с двоеточием перед циклом:
              </p>

              <p class="form__subdescription">
                labelName: for (...) { <br />
                ... <br />
                }
              </p>

              <p class="form__description">
                Вызов break &lt;labelName&gt; в цикле ниже ищет ближайший
                внешний цикл с такой меткой и переходит в его конец.
              </p>

              <p class="form__subdescription">
                <b> outer:</b> for (let i = 0; i &lt; 3; i++) { <br />
                <br />
                for (let j = 0; j &lt; 3; j++) { <br />
                <br />
                let input = prompt(`Значение на координатах (${i},${j})`, '');
                <br />
                <br />
                // если пустая строка или Отмена, то выйти из обоих циклов
                <br />
                if (!input) <b> break outer;</b> // (*) <br />
                <br />
                // сделать что-нибудь со значениями... <br />
                } <br />
                } <br />
                <br />
                alert('Готово!');
              </p>

              <p class="form__description">
                В примере выше это означает, что вызовом
                <b> break outer</b> будет разорван внешний цикл до метки с
                именем <b> outer</b>, и управление перейдёт со строки,
                помеченной (*), к alert('Готово!').
              </p>

              <p class="form__description">
                Можно размещать метку на отдельной строке:
              </p>

              <p class="form__subdescription">
                outer: <br />
                for (let i = 0; i &lt; 3; i++) { ... }
              </p>

              <p class="form__description">
                Директива continue также может быть использована с меткой. В
                этом случае управление перейдёт на следующую итерацию цикла с
                меткой.
              </p>

              <p class="form__attention">
                Метки не позволяют «прыгнуть» куда угодно
              </p>

              <p class="form__description">
                Метки не дают возможности передавать управление в произвольное
                место кода. Например, нет возможности сделать следующее:
              </p>

              <p class="form__subdescription">
                break label; // не прыгает к метке ниже <br />
                <br />
                label: for (...)
              </p>

              <p class="form__description">
                Вызов break/continue возможен только внутри цикла, и метка
                должна находиться где-то выше этой директивы.
              </p>

              <p class="form__subheading">
                <a
                  target="_blank"
                  rel="noopener"
                  href="https://learn.javascript.ru/while-for#itogo"
                  class="form__link"
                >
                  Итого</a
                >
              </p>

              <p class="form__description">Мы рассмотрели 3 вида циклов:</p>

              <p class="form__subdescription">
                <b>while</b> – Проверяет условие перед каждой итерацией.
              </p>

              <p class="form__subdescription">
                <b> do..while</b> – Проверяет условие после каждой итерации.
              </p>

              <p class="form__subdescription">
                <b>for (;;)</b> – Проверяет условие перед каждой итерацией, есть
                возможность задать дополнительные настройки.
              </p>

              <p class="form__description">
                Чтобы организовать бесконечный цикл, используют конструкцию
                <b> while (true)</b>. При этом он, как и любой другой цикл,
                может быть прерван директивой <b> break.</b>
              </p>

              <p class="form__description">
                Если на данной итерации цикла делать больше ничего не надо, но
                полностью прекращать цикл не следует – используют директиву
                <b> continue</b>.
              </p>

              <p class="form__description">
                Обе этих директивы поддерживают метки, которые ставятся перед
                циклом. Метки – единственный способ для break/continue выйти за
                пределы текущего цикла, повлиять на выполнение внешнего.
              </p>

              <p class="form__description">
                Заметим, что метки не позволяют прыгнуть в произвольное место
                кода, в JavaScript нет такой возможности.
              </p>
            </div>
          </div>
          <p class="form__subheading">
            <a
              target="_blank"
              rel="noopener"
              href="https://learn.javascript.ru/while-for#tasks"
              class="form__link-tasks"
            >
              Задачи "Циклы while и for"</a
            >
          </p>
        </section>
        <!-- Циклы while и for -->

        <!-- Конструкция "switch" -->
        <section id="switch" class="form">
          <div class="form__bloc-info">
            <h1 class="form__heading">
              Конструкция
              <a
                target="_blank"
                rel="noopener"
                href="https://learn.javascript.ru/switch#sintaksis"
                class="form__link"
              >
                "switch"</a
              >
            </h1>
            <div class="form__bloc-hidden">
              <p class="form__description">
                Конструкция switch заменяет собой сразу несколько if. Она
                представляет собой более наглядный способ сравнить выражение
                сразу с несколькими вариантами.
              </p>

              <p class="form__subheading">
                <a
                  target="_blank"
                  rel="noopener"
                  href="https://learn.javascript.ru/switch#sintaksis"
                  class="form__link"
                >
                  Синтаксис</a
                >
              </p>

              <p class="form__description">
                Конструкция switch имеет один или более блок case и
                необязательный блок default. Выглядит она так:
              </p>

              <p class="form__subdescription">
                switch(x) { <br />
                case 'value1': // if (x === 'value1') <br />
                ... <br />
                [break] <br />
                <br />
                case 'value2': // if (x === 'value2') <br />
                ... <br />
                [break] <br />
                <br />
                default: <br />
                ... <br />
                [break] <br />
                }
              </p>

              <p class="form__subheading">
                <a
                  target="_blank"
                  rel="noopener"
                  href="https://learn.javascript.ru/switch#primer-raboty"
                  class="form__link"
                >
                  Пример работы</a
                >
              </p>

              <p class="form__description">
                Пример использования switch (сработавший код выделен):
              </p>

              <p class="form__subdescription">
                let a = 4; <br />
                <br />
                switch (a) { <br />
                case 3: <br />
                alert( 'Маловато' ); <br />
                break; <br />
                case 4: <br />
                alert( 'В точку!' ); <br />
                break; <br />
                case 5: <br />
                alert( 'Перебор' ); <br />
                break; <br />
                default: <br />
                alert( "Нет таких значений" ); <br />
                }
              </p>

              <p class="form__description">
                Здесь оператор switch последовательно сравнит a со всеми
                вариантами из case.
              </p>

              <p class="form__description">
                Сначала 3, затем – так как нет совпадения – 4. Совпадение
                найдено, будет выполнен этот вариант, со строки alert( 'В
                точку!' ) и далее, до ближайшего break, который прервёт
                выполнение.
              </p>

              <p class="attention">
                Если break нет, то выполнение пойдёт ниже по следующим case, при
                этом остальные проверки игнорируются.
              </p>

              <p class="form__description">Пример без break:</p>

              <p class="form__subdescription">
                let a = 4; <br />
                <br />
                switch (a) { <br />
                case 3: <br />
                alert( 'Маловато' ); <br />
                case 4: <br />
                alert( 'В точку!' ); <br />
                case 5: <br />
                alert( 'Перебор' ); <br />
                default: <br />
                alert( "Нет таких значений" ); <br />
                }
              </p>

              <p class="form__description">
                В примере выше последовательно выполнятся три alert:
              </p>

              <p class="form__subdescription">
                alert( 'В точку!' ); <br />
                alert( 'Перебор' ); <br />
                alert( "Нет таких значений" );
              </p>

              <p class="form__attention">
                Любое выражение может быть аргументом для switch/case
              </p>

              <p class="form__description">
                И switch и case допускают любое выражение в качестве аргумента.
                Например:
              </p>

              <p class="form__subdescription">
                let a = "1"; <br />
                let b = 0; <br />
                <br />
                switch (+a) { <br />
                case b + 1: <br />
                alert("Выполнится, т.к. значением +a будет 1, что в точности
                равно b+1"); <br />
                break; <br />
                <br />
                default: <br />
                alert("Это не выполнится"); <br />
                }
              </p>

              <p class="form__description">
                В этом примере выражение +a вычисляется в 1, что совпадает с
                выражением b + 1 в case, и следовательно, код в этом блоке будет
                выполнен.
              </p>

              <p class="form__subheading">
                <a
                  target="_blank"
                  rel="noopener"
                  href="https://learn.javascript.ru/switch#gruppirovka-case"
                  class="form__link"
                >
                  Группировка «case»</a
                >
              </p>

              <p class="form__description">
                Несколько вариантов case, использующих один код, можно
                группировать. Для примера, выполним один и тот же код для case 3
                и case 5, сгруппировав их:
              </p>

              <p class="form__subdescription">
                let a = 2 + 2; <br />
                <br />
                switch (a) { <br />
                case 4: <br />
                alert('Правильно!'); <br />
                break; <br />
                <br />
                case 3: // (*) группируем оба case <br />
                case 5: <br />
                alert('Неправильно!'); <br />
                alert("Может вам посетить урок математики?"); <br />
                break; <br />
                <br />
                default: <br />
                alert('Результат выглядит странновато. Честно.'); <br />
                }
              </p>

              <p class="form__description">
                Теперь оба варианта 3 и 5 выводят одно сообщение. Возможность
                группировать case – это побочный эффект того, как switch/case
                работает без break. Здесь выполнение case 3 начинается со строки
                (*) и продолжается в case 5, потому что отсутствует break.
              </p>

              <p class="form__subheading">
                <a
                  target="_blank"
                  rel="noopener"
                  href="https://learn.javascript.ru/switch#tip-imeet-znachenie"
                  class="form__link"
                >
                  Тип имеет значение</a
                >
              </p>

              <p class="form__description">
                Нужно отметить, что проверка на равенство всегда строгая.
                Значения должны быть одного типа, чтобы выполнялось равенство.
              </p>

              <p class="form__description">
                Для примера, давайте рассмотрим следующий код:
              </p>

              <p class="form__subdescription">
                let arg = prompt("Введите число?"); <br />
                switch (arg) { <br />
                case '0': <br />
                case '1': <br />
                alert( 'Один или ноль' ); <br />
                break; <br />
                <br />
                case '2': <br />
                alert( 'Два' ); <br />
                break; <br />
                <br />
                <b>
                  case 3: <br />
                  alert( 'Никогда не выполнится!' ); <br />
                </b>
                break; <br />
                default: <br />
                alert( 'Неизвестное значение' ); <br />
                }
              </p>

              <p class="form__subdescription">
                1. Для '0' и '1' выполнится первый alert.
              </p>

              <p class="form__subdescription">2. Для '2' – второй alert.</p>

              <p class="form__subdescription">
                3. Но для 3, результат выполнения prompt будет строка "3",
                которая не соответствует строгому равенству === с числом 3.
                Таким образом, мы имеем «мёртвый код» в case 3! Выполнится
                вариант default.
              </p>

              <p class="form__subheading">
                <a
                  target="_blank"
                  rel="noopener"
                  href="https://learn.javascript.ru/switch#napishite-if-analogichnyy-switch"
                  class="form__link"
                >
                  Напишите "if", аналогичный "switch"</a
                >
              </p>

              <p class="form__description">
                Напишите if..else, соответствующий следующему switch:
              </p>

              <p class="form__subdescription">
                switch (browser) { <br />
                case 'Edge': <br />
                alert( "You've got the Edge!" ); <br />
                break; <br />
                <br />
                case 'Chrome': <br />
                case 'Firefox': <br />
                case 'Safari': <br />
                case 'Opera': <br />
                alert( 'Okay we support these browsers too' ); <br />
                break; <br />
                <br />
                default: <br />
                alert( 'We hope that this page looks ok!' ); <br />
                }
              </p>

              <p class="form__description">
                Если совсем точно следовать работе switch, то if должен
                выполнять строгое сравнение '==='. Впрочем, для таких строк,
                подойдёт и обычное сравнение '=='.
              </p>

              <p class="form__subdescription">
                if(browser == 'Edge') { <br />
                alert("You've got the Edge!"); <br />
                } else if (browser == 'Chrome' <br />
                || browser == 'Firefox' <br />
                || browser == 'Safari' <br />
                || browser == 'Opera') { <br />
                alert( 'Okay we support these browsers too' ); <br />
                } else { <br />
                alert( 'We hope that this page looks ok!' ); <br />
                }
              </p>

              <p class="form__description">
                Обратите внимание: конструкция browser == 'Chrome' || browser ==
                'Firefox' ... разбита на несколько строк для лучшей читаемости.
                Но всё равно запись через switch нагляднее.
              </p>

              <p class="form__subheading">
                <a
                  target="_blank"
                  rel="noopener"
                  href="https://learn.javascript.ru/switch#perepisat-usloviya-if-na-switch"
                  class="form__link"
                >
                  Переписать условия "if" на "switch"</a
                >
              </p>

              <p class="form__description">
                Перепишите код с использованием одной конструкции switch:
              </p>

              <p class="form__subdescription">
                const number = +prompt('Введите число между 0 и 3', ''); <br />
                <br />
                if (number === 0) { <br />
                alert('Вы ввели число 0'); <br />
                } <br />
                <br />
                if (number === 1) { <br />
                alert('Вы ввели число 1'); <br />
                } <br />
                <br />
                if (number === 2 || number === 3) { <br />
                alert('Вы ввели число 2, а может и 3'); <br />
                }
              </p>

              <p class="form__description">
                Первые две проверки – обычный case, третья разделена на два
                case:
              </p>

              <p class="form__subdescription">
                const number = +prompt('Введите число между 0 и 3', ''); <br />
                <br />
                switch (number) { <br />
                case 0: <br />
                alert('Вы ввели число 0'); <br />
                break; <br />
                <br />
                case 1: <br />
                alert('Вы ввели число 1'); <br />

                break; <br />
                <br />

                case 2: <br />
                case 3: <br />
                alert('Вы ввели число 2, а может и 3'); <br />

                break; <br />
                }
              </p>

              <p class="form__description">
                Обратите внимание: break внизу не обязателен, но ставится по
                «правилам хорошего тона». Допустим, он не стоит. Есть шанс, что
                в будущем нам понадобится добавить в конец ещё один case,
                например case 4, и мы, вполне вероятно, забудем этот break
                поставить. В результате выполнение case 2/case 3 продолжится на
                case 4 и будет ошибка.
              </p>
            </div>
          </div>

          <p class="form__subheading">
            <a
              target="_blank"
              rel="noopener"
              href="https://learn.javascript.ru/switch#tasks"
              class="form__link-tasks"
            >
              Задачи "Конструкция switch"
            </a>
          </p>
        </section>
        <!-- Конструкция "switch" -->

        <!-- Функции -->
        <section id="function" class="form">
          <div class="form__bloc-info">
            <h1 class="form__heading">
              <a
                target="_blank"
                rel="noopener"
                href="https://learn.javascript.ru/function-basics#obyavlenie-funktsii"
                class="form__link"
              >
                Функции</a
              >
            </h1>
            <div class="form__bloc-hidden">
              <p class="form__description">
                Чтобы не повторять один и тот же код во многих местах, придуманы
                функции. Функции являются основными «строительными блоками»
                программы.
              </p>

              <p class="form__description">
                Примеры встроенных функций вы уже видели – это alert(message),
                prompt(message, default) и confirm(question). Но можно создавать
                и свои.
              </p>

              <p class="form__subheading">
                <a
                  target="_blank"
                  rel="noopener"
                  href="https://learn.javascript.ru/function-basics#obyavlenie-funktsii"
                  class="form__link"
                >
                  Объявление функции</a
                >
              </p>

              <p class="form__description">
                Для создания функций мы можем использовать объявление функции.
                Пример объявления функции:
              </p>

              <p class="form__subdescription">
                function showMessage() { <br />
                alert( 'Всем привет!' ); <br />
                }
              </p>

              <p class="form__description">
                Вначале идёт ключевое слово function, после него имя функции,
                затем список параметров в круглых скобках через запятую (в
                вышеприведённом примере он пустой) и, наконец, код функции,
                также называемый «телом функции», внутри фигурных скобок.
              </p>

              <p class="form__subdescription">
                function имя(параметры) { <br />
                ...тело... <br />
                }
              </p>

              <p class="form__description">
                Наша новая функция может быть вызвана по её имени:
                showMessage(). Например:
              </p>

              <p class="form__subdescription">
                function showMessage() { <br />
                alert( 'Всем привет!' ); <br />
                } <br />
                <br />
                showMessage(); <br />
                showMessage();
              </p>

              <p class="form__description">
                Вызов showMessage() выполняет код функции. Здесь мы увидим
                сообщение дважды.
              </p>

              <p class="form__description">
                Этот пример явно демонстрирует одно из главных предназначений
                функций: избавление от дублирования кода.
              </p>

              <p class="form__description">
                Если понадобится поменять сообщение или способ его вывода –
                достаточно изменить его в одном месте: в функции, которая его
                выводит.
              </p>

              <p class="form__subheading">
                <a
                  target="_blank"
                  rel="noopener"
                  href="https://learn.javascript.ru/function-basics#lokalnye-peremennye"
                  class="form__link"
                >
                  Локальные переменные</a
                >
              </p>

              <p class="form__description">
                Переменные, объявленные внутри функции, видны только внутри этой
                функции. Например:
              </p>

              <p class="form__subdescription">
                function showMessage() { <br />
                let message = "Привет, я JavaScript!"; // локальная переменная
                <br />
                <br />
                alert( message ); <br />
                } <br />
                <br />
                showMessage(); // Привет, я JavaScript! <br />
                <br />
                alert( message ); // &lt;-- будет ошибка, т.к. переменная видна
                только внутри функции
              </p>

              <p class="form__subheading">
                <a
                  target="_blank"
                  rel="noopener"
                  href="https://learn.javascript.ru/function-basics#vneshnie-peremennye"
                  class="form__link"
                >
                  Внешние переменные</a
                >
              </p>

              <p class="form__description">
                У функции есть доступ к внешним переменным, например:
              </p>

              <p class="form__subdescription">
                let userName = 'Вася'; <br />
                <br />
                function showMessage() { <br />
                let message = 'Привет, ' + userName; <br />
                alert(message); <br />
                } <br />
                <br />
                showMessage(); // Привет, Вася
              </p>

              <p class="form__description">
                Функция обладает полным доступом к внешним переменным и может
                изменять их значение. Например:
              </p>

              <p class="form__subdescription">
                let userName = 'Вася'; <br />
                <br />
                function showMessage() { <br />
                userName = "Петя"; // (1) изменяем значение внешней переменной
                <br />
                <br />
                let message = 'Привет, ' + userName; <br />
                alert(message); <br />
                } <br />
                <br />
                alert( userName ); // Вася перед вызовом функции <br />
                <br />
                showMessage(); <br />
                <br />
                alert( userName ); // Петя, значение внешней переменной было
                изменено функцией
              </p>

              <p class="form__description">
                Внешняя переменная используется, только если внутри функции нет
                такой локальной.
              </p>

              <p class="form__description">
                Если одноимённая переменная объявляется внутри функции, тогда
                она перекрывает внешнюю. Например, в коде ниже функция
                использует локальную переменную userName. Внешняя будет
                проигнорирована:
              </p>

              <p class="form__subdescription">
                let userName = 'Вася'; <br />
                <br />
                function showMessage() { <br />
                let userName = "Петя"; // объявляем локальную переменную <br />
                <br />
                let message = 'Привет, ' + userName; // Петя <br />
                alert(message); <br />
                } <br />
                <br />
                // функция создаст и будет использовать свою собственную
                локальную переменную userName <br />
                showMessage(); <br />
                <br />
                alert( userName ); // Вася, не изменилась, функция не трогала
                внешнюю переменную
              </p>

              <p class="form__attention">Глобальные переменные</p>

              <p class="form__description">
                Переменные, объявленные снаружи всех функций, такие как внешняя
                переменная userName в вышеприведённом коде – называются
                глобальными.
              </p>

              <p class="form__description">
                Глобальные переменные видимы для любой функции (если только их
                не перекрывают одноимённые локальные переменные).
              </p>

              <p class="form__description">
                Желательно сводить использование глобальных переменных к
                минимуму. В современном коде обычно мало или совсем нет
                глобальных переменных. Хотя они иногда полезны для хранения
                важнейших «общепроектовых» данных.
              </p>

              <p class="form__subheading">
                <a
                  target="_blank"
                  rel="noopener"
                  href="https://learn.javascript.ru/function-basics#parametry"
                  class="form__link"
                >
                  Параметры</a
                >
              </p>

              <p class="form__description">
                Мы можем передать внутрь функции любую информацию, используя
                параметры (также называемые аргументами функции).
              </p>

              <p class="form__description">
                В нижеприведённом примере функции передаются два параметра: from
                и text.
              </p>

              <p class="form__subdescription">
                function showMessage(from, text) { // аргументы: from, text
                <br />
                alert(from + ': ' + text); <br />
                } <br />
                <br />
                showMessage('Аня', 'Привет!'); // Аня: Привет! (*) <br />
                showMessage('Аня', "Как дела?"); // Аня: Как дела? (**)
              </p>

              <p class="form__description">
                Когда функция вызывается в строках (*) и (**), переданные
                значения копируются в локальные переменные from и text. Затем
                они используются в теле функции.
              </p>

              <p class="form__description">
                Вот ещё один пример: у нас есть переменная from, и мы передаём
                её функции. Обратите внимание: функция изменяет значение from,
                но это изменение не видно снаружи. Функция всегда получает
                только копию значения:
              </p>

              <p class="form__subdescription">
                function showMessage(from, text) { <br />
                <br />
                from = '*' + from + '*'; // немного украсим "from" <br />
                <br />
                alert( from + ': ' + text ); <br />
                } <br />
                <br />
                let from = "Аня"; <br />
                <br />
                showMessage(from, "Привет"); // *Аня*: Привет <br />
                <br />
                // значение "from" осталось прежним, функция изменила значение
                локальной переменной <br />
                alert( from ); // Аня
              </p>

              <p class="form__subheading">
                <a
                  target="_blank"
                  rel="noopener"
                  href="https://learn.javascript.ru/function-basics#parametry-po-umolchaniyu"
                  class="form__link"
                >
                  Параметры по умолчанию</a
                >
              </p>

              <p class="form__description">
                Если параметр не указан, то его значением становится undefined.
                Например, вышеупомянутая функция showMessage(from, text) может
                быть вызвана с одним аргументом:
              </p>

              <p class="form__subdescription">showMessage("Аня");</p>

              <p class="form__description">
                Это не приведёт к ошибке. Такой вызов выведет "Аня: undefined".
                В вызове не указан параметр text, поэтому предполагается, что
                text === undefined.
              </p>

              <p class="form__description">
                Если мы хотим задать параметру text значение по умолчанию, мы
                должны указать его после =:
              </p>

              <p class="form__subdescription">
                function showMessage(from, text = "текст не добавлен") { <br />
                alert( from + ": " + text ); <br />
                } <br />
                <br />
                showMessage("Аня"); // Аня: текст не добавлен
              </p>

              <p class="form__description">
                Теперь, если параметр text не указан, его значением будет "текст
                не добавлен"
              </p>

              <p class="form__description">
                В данном случае "текст не добавлен" это строка, но на её месте
                могло бы быть и более сложное выражение, которое бы вычислялось
                и присваивалось при отсутствии параметра. Например:
              </p>

              <p class="form__subdescription">
                function showMessage(from, text = anotherFunction()) { <br />
                // anotherFunction() выполнится только если не передан text
                <br />
                // результатом будет значение text <br />
                }
              </p>

              <p class="form__attention">Вычисление параметров по умолчанию</p>

              <p class="form__description">
                В JavaScript параметры по умолчанию вычисляются каждый раз,
                когда функция вызывается без соответствующего параметра.
              </p>

              <p class="form__description">
                В примере выше anotherFunction() будет вызываться каждый раз,
                когда showMessage() вызывается без параметра text.
              </p>

              <p class="form__attention">
                Использование параметров по умолчанию в ранних версиях
                JavaScript
              </p>

              <p class="form__description">
                Ранние версии JavaScript не поддерживали параметры по умолчанию.
                Поэтому существуют альтернативные способы, которые могут
                встречаться в старых скриптах.
              </p>

              <p class="form__description">
                Например, явная проверка на undefined:
              </p>

              <p class="form__subdescription">
                function showMessage(from, text) { <br />
                if (text === undefined) { <br />
                text = 'текст не добавлен'; <br />
                } <br />
                <br />
                alert( from + ": " + text ); <br />
                }
              </p>

              <p class="form__description">…Или с помощью оператора ||:</p>

              <p class="form__subdescription">
                function showMessage(from, text) { <br />
                // Если значение text ложно, тогда присвоить параметру text
                значение по умолчанию <br />
                text = text || 'текст не добавлен'; <br />
                ... <br />
                }
              </p>

              <p class="form__subheading">
                <a
                  target="_blank"
                  rel="noopener"
                  href="https://learn.javascript.ru/function-basics#vozvrat-znacheniya"
                  class="form__link"
                >
                  Возврат значения</a
                >
              </p>

              <p class="form__description">
                Функция может вернуть результат, который будет передан в
                вызвавший её код. Простейшим примером может служить функция
                сложения двух чисел:
              </p>

              <p class="form__subdescription">
                function sum(a, b) { <br />
                return a + b; <br />
                } <br />
                <br />
                let result = sum(1, 2); <br />
                alert( result ); // 3
              </p>

              <p class="form__description">
                Директива return может находиться в любом месте тела функции.
                Как только выполнение доходит до этого места, функция
                останавливается, и значение возвращается в вызвавший её код
                (присваивается переменной result выше).
              </p>

              <p class="form__description">
                Вызовов return может быть несколько, например:
              </p>

              <p class="form__subdescription">
                function checkAge(age) { <br />
                if (age > 18) { <br />
                return true; <br />
                } else { <br />
                return confirm('А родители разрешили?'); <br />
                } <br />
                } <br />
                <br />
                let age = prompt('Сколько вам лет?', 18); <br />
                <br />
                if ( checkAge(age) ) { <br />
                alert( 'Доступ получен' ); <br />
                } else { <br />
                alert( 'Доступ закрыт' ); <br />
                }
              </p>

              <p class="form__description">
                Возможно использовать return и без значения. Это приведёт к
                немедленному выходу из функции. Например:
              </p>

              <p class="form__subdescription">
                function showMovie(age) { <br />
                if ( !checkAge(age) ) { <br />
                return; <br />
                } <br />
                <br />
                alert( "Вам показывается кино" ); // (*) <br />
                // ... <br />
                }
              </p>

              <p class="form__description">
                В коде выше, если checkAge(age) вернёт false, showMovie не
                выполнит alert.
              </p>

              <p class="form__attention">
                Результат функции с пустым return или без него – undefined
              </p>

              <p class="form__description">
                Если функция не возвращает значения, это всё равно, как если бы
                она возвращала undefined:
              </p>

              <p class="form__subdescription">
                function doNothing() { /* пусто */ } <br />
                <br />
                alert( doNothing() === undefined ); // true
              </p>

              <p class="form__description">
                Пустой return аналогичен return undefined:
              </p>

              <p class="form__subdescription">
                function doNothing() { <br />
                return; <br />
                } <br />
                <br />
                alert( doNothing() === undefined ); // true
              </p>

              <p class="form__attention">
                Никогда не добавляйте перевод строки между return и его
                значением
              </p>

              <p class="form__description">
                Для длинного выражения в return может быть заманчиво разместить
                его на нескольких отдельных строках, например так:
              </p>

              <p class="form__subdescription">
                return <br />
                (some + long + expression + or + whatever * f(a) + f(b))
              </p>

              <p class="form__description">
                Код не выполнится, потому что интерпретатор JavaScript подставит
                точку с запятой после return. Для него это будет выглядеть так:
              </p>

              <p class="form__subdescription">
                return; <br />
                (some + long + expression + or + whatever * f(a) + f(b))
              </p>

              <p class="form__description">
                Таким образом, это фактически стало пустым return.
              </p>

              <p class="form__description">
                Если мы хотим, чтобы возвращаемое выражение занимало несколько
                строк, нужно начать его на той же строке, что и return. Или,
                хотя бы, поставить там <b>открывающую скобку</b> , вот так:
              </p>

              <p class="form__subdescription">
                return ( <br />
                some + long + expression <br />
                + or + <br />
                whatever * f(a) + f(b) <br />
                )
              </p>

              <p class="form__description">
                И тогда всё сработает, как задумано.
              </p>

              <p class="form__subheading">
                <a
                  target="_blank"
                  rel="noopener"
                  href="https://learn.javascript.ru/function-basics#function-naming"
                  class="form__link"
                >
                  Выбор имени функции</a
                >
              </p>

              <p class="form__description">
                Функция – это действие. Поэтому имя функции обычно является
                глаголом. Оно должно быть простым, точным и описывать действие
                функции, чтобы программист, который будет читать код, получил
                верное представление о том, что делает функция.
              </p>

              <p class="form__description">
                Как правило, используются глагольные префиксы, обозначающие
                общий характер действия, после которых следует уточнение. Обычно
                в командах разработчиков действуют соглашения, касающиеся
                значений этих префиксов.
              </p>

              <p class="form__description">
                Например, функции, начинающиеся с "show" обычно что-то
                показывают.
              </p>

              <p class="form__description">Функции, начинающиеся с…</p>

              <p class="form__subdescription">
                <b> "get…" </b> – возвращают значение,
              </p>

              <p class="form__subdescription">
                <b> "calc…" </b> – что-то вычисляют,
              </p>

              <p class="form__subdescription">
                <b> "create…" </b> – что-то создают,
              </p>

              <p class="form__subdescription">
                <b> "check…" </b> – что-то проверяют и возвращают логическое
                значение, и т.д.
              </p>

              <p class="form__description">Примеры таких имён:</p>

              <p class="form__subdescription">
                <b> showMessage(..)</b> // показывает сообщение <br />
                <b> getAge(..) </b> // возвращает возраст (в каком либо
                значении) <br />
                <b> calcSum(..) </b> // вычисляет сумму и возвращает результат
                <br />
                <b> createForm(..) </b> // создаёт форму (и обычно возвращает
                её) <br />
                <b> checkPermission(..)</b> // проверяет доступ, возвращая
                true/false
              </p>

              <p class="form__description">
                Благодаря префиксам, при первом взгляде на имя функции
                становится понятным что делает её код, и какое значение она
                может возвращать.
              </p>

              <p class="form__attention">Одна функция – одно действие</p>

              <p class="form__description">
                Функция должна делать только то, что явно подразумевается её
                названием. И это должно быть одним действием.
              </p>

              <p class="form__description">
                Два независимых действия обычно подразумевают две функции, даже
                если предполагается, что они будут вызываться вместе (в этом
                случае мы можем создать третью функцию, которая будет их
                вызывать).
              </p>

              <p class="form__description">
                Несколько примеров, которые нарушают это правило:
              </p>

              <p class="form__subdescription">
                <b> getAge</b> – будет плохим выбором, если функция будет
                выводить alert с возрастом (должна только возвращать его).
              </p>

              <p class="form__subdescription">
                <b> createForm</b> – будет плохим выбором, если функция будет
                изменять документ, добавляя форму в него (должна только
                создавать форму и возвращать её).
              </p>

              <p class="form__subdescription">
                <b>checkPermission</b> – будет плохим выбором, если функция
                будет отображать сообщение с текстом доступ разрешён/запрещён
                (должна только выполнять проверку и возвращать её результат).
              </p>

              <p class="form__description">
                В этих примерах использовались общепринятые смыслы префиксов.
                Конечно, вы в команде можете договориться о других значениях, но
                обычно они мало отличаются от общепринятых. В любом случае вы и
                ваша команда должны точно понимать, что значит префикс, что
                функция с ним может делать, а чего не может.
              </p>

              <p class="form__attention">Сверхкороткие имена функций</p>

              <p class="form__description">
                Имена функций, которые используются очень часто, иногда делают
                сверхкороткими.
              </p>

              <p class="form__description">
                Например, во фреймворке jQuery есть функция с именем $. В
                библиотеке Lodash основная функция представлена именем _.
              </p>

              <p class="form__description">
                Это исключения. В основном имена функций должны быть в меру
                краткими и описательными.
              </p>

              <p class="form__subheading">
                <a
                  target="_blank"
                  rel="noopener"
                  href="https://learn.javascript.ru/function-basics#funktsii-kommentarii"
                  class="form__link"
                >
                  Функции == Комментарии</a
                >
              </p>

              <p class="form__description">
                Функции должны быть короткими и делать только что-то одно. Если
                это что-то большое, имеет смысл разбить функцию на несколько
                меньших. Иногда следовать этому правилу непросто, но это
                определённо хорошее правило.
              </p>

              <p class="form__description">
                Небольшие функции не только облегчают тестирование и отладку –
                само существование таких функций выполняет роль хороших
                комментариев!
              </p>

              <p class="form__description">
                Например, сравним ниже две функции showPrimes(n). Каждая из них
                выводит простое число до n.
              </p>

              <p class="form__description">
                Первый вариант использует метку nextPrime:
              </p>

              <p class="form__subdescription">
                function showPrimes(n) { <br />
                nextPrime: for (let i = 2; i &lt; n; i++) { <br />
                <br />
                for (let j = 2; j &lt; i; j++) { <br />
                if (i % j == 0) continue nextPrime; <br />
                } <br />
                <br />
                alert( i ); // простое <br />
                } <br />
                }
              </p>

              <p class="form__description">
                Второй вариант использует дополнительную функцию isPrime(n) для
                проверки на простое:
              </p>

              <p class="form__subdescription">
                function showPrimes(n) { <br />
                <br />
                for (let i = 2; i &lt; n; i++) { <br />
                if (!isPrime(i)) continue; <br />
                <br />
                alert(i); // простое <br />
                } <br />
                } <br />
                <br />
                function isPrime(n) { <br />
                for (let i = 2; i &lt; n; i++) { <br />
                if ( n % i == 0) return false; <br />
                } <br />
                return true; <br />
                }
              </p>

              <p class="form__description">
                Второй вариант легче для понимания, не правда ли? Вместо куска
                кода мы видим название действия (isPrime). Иногда разработчики
                называют такой код самодокументируемым.
              </p>

              <p class="form__description">
                Таким образом, допустимо создавать функции, даже если мы не
                планируем повторно использовать их. Такие функции структурируют
                код и делают его более понятным.
              </p>

              <p class="form__subheading">
                <a
                  target="_blank"
                  rel="noopener"
                  href="https://learn.javascript.ru/function-basics#itogo"
                  class="form__link"
                >
                  Итого</a
                >
              </p>

              <p class="form__description">Объявление функции имеет вид:</p>

              <p class="form__subdescription">
                function имя(параметры, через, запятую) { <br />
                /* тело, код функции */ <br />
                }
              </p>

              <p class="form__subdescription">
                Передаваемые значения копируются в параметры функции и
                становятся локальными переменными.
              </p>

              <p class="form__subdescription">
                Функции имеют доступ к внешним переменным. Но это работает
                только изнутри наружу. Код вне функции не имеет доступа к её
                локальным переменным.
              </p>

              <p class="form__subdescription">
                Функция может возвращать значение. Если этого не происходит,
                тогда результат равен undefined.
              </p>

              <p class="form__description">
                Для того, чтобы сделать код более чистым и понятным,
                рекомендуется использовать локальные переменные и параметры
                функций, не пользоваться внешними переменными.
              </p>

              <p class="form__description">
                Функция, которая получает параметры, работает с ними и затем
                возвращает результат, гораздо понятнее функции, вызываемой без
                параметров, но изменяющей внешние переменные, что чревато
                побочными эффектами.
              </p>

              <p class="form__description">Именование функций:</p>

              <p class="form__subdescription">
                Имя функции должно понятно и чётко отражать, что она делает.
                Увидев её вызов в коде, вы должны тут же понимать, что она
                делает, и что возвращает.
              </p>

              <p class="form__subdescription">
                Функция – это действие, поэтому её имя обычно является глаголом.
              </p>

              <p class="form__subdescription">
                Есть много общепринятых префиксов, таких как: create…, show…,
                get…, check… и т.д. Пользуйтесь ими как подсказками,
                поясняющими, что делает функция.
              </p>

              <p class="form__description">
                Функции являются основными строительными блоками скриптов.
              </p>
            </div>
          </div>

          <p class="form__subheading">
            <a
              target="_blank"
              rel="noopener"
              href="https://learn.javascript.ru/function-basics#tasks"
              class="form__link-tasks"
            >
              Задачи "Функции"
            </a>
          </p>
        </section>
        <!-- Функции -->

        <!-- Function Expression и «call back» -->
        <section id="Function-Expression-call-back" class="form">
          <div class="form__bloc-info">
            <h1 class="form__heading">
              Function
              <a
                target="_blank"
                rel="noopener"
                href="https://learn.javascript.ru/function-expressions"
                class="form__link"
              >
                Expression и «колбэки»</a
              >
            </h1>
            <div class="form__bloc-hidden">
              <p class="form__description">
                Функция в JavaScript – это не магическая языковая структура, а
                особого типа значение. Синтаксис, который мы использовали до
                этого, называется Function Declaration (Объявление Функции):
              </p>

              <p class="form__subdescription">
                function sayHi() { <br />
                alert( "Привет" ); <br />
                }
              </p>

              <p class="form__description">
                Существует ещё один синтаксис создания функций, который
                называется <b> Function Expression</b> (Функциональное
                Выражение). Оно выглядит вот так:
              </p>

              <p class="form__subdescription">
                let sayHi = function() { <br />
                alert( "Привет" ); <br />
                };
              </p>

              <p class="form__description">
                В коде выше функция создаётся и явно присваивается переменной,
                как любое другое значение. По сути без разницы, как мы
                определили функцию, это просто значение, хранимое в переменной
                sayHi. Смысл обоих примеров кода одинаков: "создать функцию и
                поместить её значение в переменную sayHi". Мы можем даже вывести
                это значение с помощью alert:
              </p>

              <p class="form__subdescription">
                function sayHi() { <br />
                alert( "Привет" ); <br />
                } <br />
                <br />
                alert( sayHi ); // выведет код функции
              </p>

              <p class="form__description">
                Обратите внимание, что последняя строка не вызывает функцию
                sayHi, после её имени нет круглых скобок. Существуют языки
                программирования, в которых любое упоминание имени функции
                совершает её вызов. JavaScript – не один из них.
              </p>

              <p class="form__description">
                В JavaScript функции – это значения, поэтому мы и обращаемся с
                ними, как со значениями. Код выше выведет строковое
                представление функции, которое является её исходным кодом.
              </p>

              <p class="form__description">
                Конечно, функция – не обычное значение, в том смысле, что мы
                можем вызвать его при помощи скобок: sayHi().
              </p>

              <p class="form__description">
                Но всё же это значение. Поэтому мы можем делать с ним то же
                самое, что и с любым другим значением.
              </p>

              <p class="form__description">
                Мы можем скопировать функцию в другую переменную:
              </p>

              <p class="form__subdescription">
                function sayHi() { // (1) создаём <br />
                alert( "Привет" ); <br />
                } <br />
                <br />
                let func = sayHi; // (2) копируем <br />
                <br />
                func(); // Привет // (3) вызываем копию (работает)! <br />
                sayHi(); // Привет // прежняя тоже работает (почему бы нет)
              </p>

              <p class="form__description">
                Давайте подробно разберём всё, что тут произошло:
              </p>

              <p class="form__subdescription">
                1. Объявление Function Declaration (1) создало функцию и
                присвоило её значение переменной с именем sayHi.
              </p>

              <p class="form__subdescription">
                2. В строке (2) мы скопировали её значение в переменную func.
                Обратите внимание (ещё раз): нет круглых скобок после sayHi.
                Если бы они были, то выражение func = sayHi() записало бы
                результат вызова sayHi() в переменную func, а не саму функцию
                sayHi.
              </p>

              <p class="form__subdescription">
                3. Теперь функция может быть вызвана с помощью обеих переменных
                sayHi() и func().
              </p>

              <p class="form__description">
                Заметим, что мы могли бы использовать и Function Expression для
                того, чтобы создать sayHi в первой строке:
              </p>

              <p class="form__subdescription">
                let sayHi = function() { <br />
                alert( "Привет" ); <br />
                }; <br />
                <br />
                let func = sayHi; <br />
                // ...
              </p>

              <p class="form__description">Результат был бы таким же.</p>

              <p class="form__attention">
                Зачем нужна точка с запятой в конце?
              </p>

              <p class="form__description">
                У вас мог возникнуть вопрос: Почему в Function Expression
                ставится точка с запятой ; на конце, а в Function Declaration
                нет:
              </p>

              <p class="form__subdescription">
                function sayHi() { <br />
                // ... <br />
                } <br />
                <br />
                let sayHi = function() { <br />
                // ... <br />
                };
              </p>

              <p class="form__description">Ответ прост:</p>

              <p class="form__subdescription">
                Нет необходимости в ; в конце блоков кода и синтаксических
                конструкций, которые их используют, таких как if { ... }, for {
                }, function f { } и т.д.
              </p>

              <p class="form__subdescription">
                Function Expression использует внутри себя инструкции
                присваивания let sayHi = ...; как значение. Это не блок кода, а
                выражение с присваиванием. Таким образом, точка с запятой не
                относится непосредственно к Function Expression, она лишь
                завершает инструкцию.
              </p>

              <p class="form__subheading">
                <a
                  target="_blank"
                  rel="noopener"
                  href="https://learn.javascript.ru/function-expressions#funktsii-kolbeki"
                  class="form__link"
                >
                  Функции-«колбэки»</a
                >
              </p>

              <p class="form__description">
                Рассмотрим ещё примеры функциональных выражений и передачи
                функции как значения. Давайте напишем функцию
                <b> ask(question, yes, no)</b> с тремя параметрами:
              </p>

              <p class="form__subdescription">
                <b> question </b> <br />
                Текст вопроса
              </p>

              <p class="form__subdescription">
                <b> yes </b> <br />
                Функция, которая будет вызываться, если ответ будет «Yes»
              </p>

              <p class="form__subdescription">
                <b> no </b> <br />
                Функция, которая будет вызываться, если ответ будет «No»
              </p>

              <p class="form__description">
                Наша функция должна задать вопрос question и, в зависимости от
                того, как ответит пользователь, вызвать <b> yes()</b> или
                <b> no()</b>:
              </p>

              <p class="form__subdescription">
                function ask(question, yes, no) { <br />
                if (confirm(question)) yes() <br />
                else no(); <br />
                } <br />
                <br />
                function showOk() { <br />
                alert( "Вы согласны." ); <br />

                } <br />
                <br />
                function showCancel() { <br />
                alert( "Вы отменили выполнение." ); <br />
                } <br />
                <br />
                // использование: функции showOk, showCancel передаются в
                качестве аргументов ask <br />
                ask("Вы согласны?", showOk, showCancel);
              </p>

              <p class="form__description">
                На практике подобные функции очень полезны. Основное отличие
                «реальной» функции ask от примера выше будет в том, что она
                использует более сложные способы взаимодействия с пользователем,
                чем простой вызов confirm. В браузерах такие функции обычно
                отображают красивые диалоговые окна. Но это уже другая история.
              </p>

              <p class="form__attention">
                Аргументы функции ask ещё называют функциями-колбэками или
                просто колбэками.
              </p>

              <p class="form__attention">
                Ключевая идея в том, что мы передаём функцию и ожидаем, что она
                вызовется обратно (от англ. «call back» – обратный вызов)
                когда-нибудь позже, если это будет необходимо. В нашем случае,
                showOk становится колбэком’ для ответа «yes», а showCancel – для
                ответа «no».
              </p>

              <p class="form__description">
                Мы можем переписать этот пример значительно короче, используя
                Function Expression:
              </p>

              <p class="form__subdescription">
                function ask(question, yes, no) { <br />
                if (confirm(question)) yes() <br />
                else no(); <br />
                } <br />
                <br />
                ask( <br />
                "Вы согласны?", <br />
                function() { alert("Вы согласились."); }, <br />
                function() { alert("Вы отменили выполнение."); } <br />
                );
              </p>

              <p class="form__description">
                Здесь функции объявляются прямо внутри вызова ask(...). У них
                нет имён, поэтому они называются анонимными. Такие функции
                недоступны снаружи ask (потому что они не присвоены переменным),
                но это как раз то, что нам нужно. Подобный код, появившийся в
                нашем скрипте выглядит очень естественно, в духе JavaScript.
              </p>

              <p class="form__attention">
                Функция – это значение, представляющее «действие» <br />
                <br />
                Обычные значения, такие как строки или числа представляют собой
                данные. <br /><br />
                Функции, с другой стороны, можно воспринимать как «действия».
                <br /><br />
                Мы можем передавать их из переменной в переменную и запускать,
                когда захотим.
              </p>

              <p class="form__subheading">
                <a
                  target="_blank"
                  rel="noopener"
                  href="https://learn.javascript.ru/function-expressions#function-expression-v-sravnenii-s-function-declaration"
                  class="form__link"
                >
                  Function Expression в сравнении с Function Declaration</a
                >
              </p>

              <p class="form__description">
                Давайте разберём ключевые отличия Function Declaration от
                Function Expression.
              </p>

              <p class="form__description">
                Во-первых, синтаксис: как определить, что есть что в коде.
              </p>

              <p class="form__subdescription">
                Function Declaration: функция объявляется отдельной конструкцией
                «function…» в основном потоке кода.
              </p>

              <p class="form__subdescription">
                // Function Declaration <br />
                function sum(a, b) { <br />
                return a + b; <br />
                }
              </p>

              <p class="form__subdescription">
                Function Expression: функция, созданная внутри другого выражения
                или синтаксической конструкции. В данном случае функция
                создаётся в правой части «выражения присваивания» =:
              </p>

              <p class="form__subdescription">
                // Function Expression <br />
                let sum = function(a, b) { <br />
                return a + b; <br />
                };
              </p>

              <p class="form__description">
                Более тонкое отличие состоит, в том, когда создаётся функция
                движком JavaScript.
              </p>

              <p class="form__attention">
                Function Expression создаётся, когда выполнение доходит до него,
                и затем уже может использоваться.
              </p>

              <p class="form__description">
                После того, как поток выполнения достигнет правой части
                выражения присваивания let sum = function… – с этого момента,
                функция считается созданной и может быть использована (присвоена
                переменной, вызвана и т.д. ).
              </p>

              <p class="form__description">С Function Declaration всё иначе.</p>

              <p class="form__attention">
                Function Declaration можно использовать во всем скрипте (или
                блоке кода, если функция объявлена в блоке).
              </p>

              <p class="form__description">
                Другими словами, когда движок JavaScript готовится выполнять
                скрипт или блок кода, прежде всего он ищет в нём Function
                Declaration и создаёт все такие функции. Можно считать этот
                процесс «стадией инициализации».
              </p>

              <p class="form__description">
                И только после того, как все объявления Function Declaration
                будут обработаны, продолжится выполнение.
              </p>

              <p class="form__description">
                В результате, функции, созданные, как Function Declaration могут
                быть вызваны раньше своих определений. Например, так будет
                работать:
              </p>

              <p class="form__subdescription">
                sayHi("Вася"); // Привет, Вася <br />
                <br />
                function sayHi(name) { <br />
                alert( `Привет, ${name}` ); <br />
                }
              </p>

              <p class="form__description">
                Функция sayHi была создана, когда движок JavaScript
                подготавливал скрипт к выполнению, и такая функция видна повсюду
                в этом скрипте.
              </p>

              <p class="form__description">
                …Если бы это было Function Expression, то такой код вызовет
                ошибку:
              </p>

              <p class="form__subdescription">
                sayHi("Вася"); // ошибка! <br />
                <br />
                let sayHi = function(name) { // (*) магии больше нет <br />
                alert( `Привет, ${name}` ); <br />
                }; <br />
              </p>

              <p class="form__description">
                Функции, объявленные при помощи Function Expression, создаются
                тогда, когда выполнение доходит до них. Это случится только на
                строке, помеченной звёздочкой (*). Слишком поздно.
              </p>

              <p class="form__description">
                Ещё одна важная особенность Function Declaration заключается в
                их блочной области видимости.
              </p>

              <p class="form__attention">
                В строгом режиме, когда Function Declaration находится в блоке
                {...}, функция доступна везде внутри блока. Но не снаружи него.
              </p>

              <p class="form__description">
                Для примера давайте представим, что нам нужно создать функцию
                welcome() в зависимости от значения переменной age, которое мы
                получим во время выполнения кода. И затем запланируем
                использовать её когда-нибудь в будущем. Такой код, использующий
                Function Declaration, работать не будет:
              </p>

              <p class="form__subdescription">
                let age = prompt("Сколько Вам лет?", 18); <br />
                <br />
                // в зависимости от условия объявляем функцию <br />
                if (age &lt; 18) { <br />
                <br />
                function welcome() { <br />
                alert("Привет!"); <br />
                } <br />
                <br />
                } else { <br />
                <br />
                function welcome() { <br />
                alert("Здравствуйте!"); <br />
                } <br />
                <br />
                } <br />
                <br />
                // ...не работает <br />
                welcome(); // Error: welcome is not defined
              </p>

              <p class="form__description">
                Это произошло, так как объявление Function Declaration видимо
                только внутри блока кода, в котором располагается. Вот ещё один
                пример:
              </p>

              <p class="form__subdescription">
                let age = 16; // присвоим для примера 16 <br />
                <br />
                if (age &lt; 18) { <br />
                welcome(); // (выполнится) <br />
                <br />
                function welcome() { // <br />
                alert("Привет!"); // Function Declaration доступно <br />
                } // во всём блоке кода, в котором объявлено <br />
                <br />
                welcome(); // (выполнится) <br />
                <br />
                } else { <br />
                <br />
                function welcome() { <br />
                alert("Здравствуйте!"); <br />
                } <br />
                } <br />
                <br />
                // здесь фигурная скобка закрывается, <br />
                // поэтому Function Declaration, созданные внутри блока кода
                выше -- недоступны отсюда. <br />
                <br />
                welcome(); // Ошибка: welcome is not defined
              </p>

              <p class="form__description">
                Что можно сделать, чтобы welcome была видима снаружи if?
              </p>

              <p class="form__description">
                Верным подходом будет воспользоваться функцией, объявленной при
                помощи Function Expression, и присвоить значение welcome
                переменной, объявленной снаружи if, что обеспечит нам нужную
                видимость.
              </p>

              <p class="form__description">
                Такой код работает, как ожидалось:
              </p>

              <p class="form__subdescription">
                let age = prompt("Сколько Вам лет?", 18); <br />
                <br />
                let welcome; <br />
                <br />
                if (age &lt; 18) { <br />
                <br />
                welcome = function() { <br />
                alert("Привет!"); <br />
                }; <br />
                <br />
                } else { <br />
                <br />
                welcome = function() { <br />
                alert("Здравствуйте!"); <br />
                }; <br />
                <br />
                } <br />
                <br />
                welcome(); // теперь всё в порядке
              </p>

              <p class="form__description">
                Можно упростить этот код ещё сильнее, используя условный
                оператор ?:
              </p>

              <p class="form__subdescription">
                let age = prompt("Сколько Вам лет?", 18); <br />
                <br />
                let welcome = (age &lt; 18) ? <br />
                function() { alert("Привет!"); } : <br />
                function() { alert("Здравствуйте!"); }; <br />
                <br />
                welcome(); // теперь всё в порядке
              </p>

              <p class="form__attention">
                Когда использовать Function Declaration, а когда Function
                Expression?
              </p>

              <p class="form__description">
                Как правило, если нам понадобилась функция, в первую очередь
                нужно рассматривать синтаксис Function Declaration, который мы
                использовали до этого. Он даёт нам больше свободы в том, как мы
                можем организовывать код. Функции, объявленные таким образом,
                можно вызывать до их объявления.
              </p>

              <p class="form__description">
                Также функции вида function f(…) {…} чуть более заметны в коде,
                чем let f = function(…) {…}. Function Declaration легче «ловятся
                глазами».
              </p>

              <p class="form__description">
                …Но если Function Declaration нам не подходит по какой-то
                причине (мы рассмотрели это в примере выше), то можно
                использовать объявление при помощи Function Expression.
              </p>

              <p class="form__subheading">
                <a
                  target="_blank"
                  rel="noopener"
                  href="https://learn.javascript.ru/function-expressions#itogo"
                  class="form__link"
                >
                  Итого</a
                >
              </p>

              <p class="form__subdescription">
                Функции – это значения. Они могут быть присвоены, скопированы
                или объявлены в другом месте кода.
              </p>

              <p class="form__subdescription">
                Если функция объявлена как отдельная инструкция в основном
                потоке кода, то это Function Declaration.
              </p>

              <p class="form__subdescription">
                Если функция была создана как часть выражения, то считается, что
                эта функция объявлена при помощи Function Expression.
              </p>

              <p class="form__subdescription">
                Function Declaration обрабатываются перед выполнением блока
                кода. Они видны во всём блоке.
              </p>

              <p class="form__subdescription">
                Функции, объявленные при помощи Function Expression, создаются,
                только когда поток выполнения достигает их.
              </p>

              <p class="form__description">
                В большинстве случаев, когда нам нужно создать функцию,
                предпочтительно использовать Function Declaration, т.к. функция
                будет видима до своего объявления в коде. Это позволяет более
                гибко организовывать код, и улучшает его читаемость.
              </p>

              <p class="form__description">
                Таким образом, мы должны прибегать к объявлению функций при
                помощи Function Expression в случае, когда синтаксис Function
                Declaration не подходит для нашей задачи. Мы рассмотрели
                несколько таких примеров в этой главе, и рассмотрим их ещё
                больше в будущем.
              </p>
            </div>
          </div>
        </section>
        <!-- Function Expression и «call back» -->

        <!-- Функции-стрелки, основы -->
        <section id="strelochnye-funktsii" class="form">
          <div class="form__bloc-info">
            <h1 class="form__heading">
              Функции
              <a
                target="_blank"
                rel="noopener"
                href="https://learn.javascript.ru/arrow-functions-basics#mnogostrochnye-strelochnye-funktsii"
                class="form__link"
              >
                -стрелки, основы</a
              >
            </h1>
            <div class="form__bloc-hidden">
              <p class="form__description">
                Существует ещё более простой и краткий синтаксис для создания
                функций, который часто лучше, чем синтаксис Function Expression.
              </p>

              <p class="form__description">
                Он называется «функции-стрелки» или «стрелочные функции» (arrow
                functions), т.к. выглядит следующим образом:
              </p>

              <p class="form__subdescription">
                let func = (arg1, arg2, ...argN) => expression
              </p>

              <p class="form__description">
                …Такой код создаёт функцию func с аргументами arg1..argN и
                вычисляет expression с правой стороны с их использованием,
                возвращая результат. Другими словами, это более короткий вариант
                такой записи:
              </p>

              <p class="form__subdescription">
                let func = function(arg1, arg2, ...argN) { <br />
                return expression;<br />
                };
              </p>

              <p class="form__description">
                Давайте взглянем на конкретный пример:
              </p>

              <p class="form__subdescription">
                let sum = (a, b) => a + b; <br />
                <br />
                /* Более короткая форма для: <br />
                <br />
                let sum = function(a, b) { <br />
                return a + b; <br />
                }; <br />
                */ <br />
                <br />
                alert( sum(1, 2) ); // 3
              </p>

              <p class="form__attention">
                То есть, <b> (a, b) => a + b</b> задаёт функцию с двумя
                аргументами a и b, которая при запуске вычисляет выражение
                справа a + b и возвращает его результат.
              </p>

              <p class="form__subdescription">
                Если у нас только один аргумент, то круглые скобки вокруг
                параметров можно опустить, сделав запись ещё короче:
              </p>

              <p class="form__subdescription">
                // тоже что и <br />
                // let double = function(n) { return n * 2 } <br />
                let double = n => n * 2; <br />
                <br />
                alert( double(3) ); // 6
              </p>

              <p class="form__subdescription">
                Если нет аргументов, указываются пустые круглые скобки:
              </p>

              <p class="form__subdescription">
                let sayHi = () => alert("Hello!"); <br />
                <br />
                sayHi();
              </p>

              <p class="form__description">
                Функции-стрелки могут быть использованы так же, как и Function
                Expression. Например, для динамического создания функции:
              </p>

              <p class="form__subdescription">
                let age = prompt("Сколько Вам лет?", 18); <br />
                <br />
                let welcome = (age &lt; 18) ? <br />
                () => alert('Привет') : <br />
                () => alert("Здравствуйте!"); <br />
                <br />
                welcome(); // теперь всё в порядке
              </p>

              <p class="form__description">
                Поначалу функции-стрелки могут показаться необычными и
                трудночитаемыми, но это быстро пройдёт, как только глаза
                привыкнут к этим конструкциям. Они очень удобны для простых
                однострочных действий, когда лень писать много букв.
              </p>

              <p class="form__subheading">
                <a
                  target="_blank"
                  rel="noopener"
                  href="https://learn.javascript.ru/arrow-functions-basics#mnogostrochnye-strelochnye-funktsii"
                  class="form__link"
                >
                  Многострочные стрелочные функции</a
                >
              </p>

              <p class="form__description">
                В примерах выше аргументы использовались слева от =>, а справа
                вычислялось выражение с их значениями.
              </p>

              <p class="form__description">
                Порой нам нужно что-то посложнее, например, выполнить несколько
                инструкций. Это также возможно, нужно лишь заключить инструкции
                в фигурные скобки. И использовать return внутри них, как в
                обычной функции. Например:
              </p>

              <p class="form__subdescription">
                let sum = (a, b) => { // фигурная скобка, открывающая тело
                многострочной функции <br />
                let result = a + b; <br />
                return result; // при фигурных скобках для возврата значения
                нужно явно вызвать return <br />
                }; <br />
                <br />
                alert( sum(1, 2) ); // 3
              </p>

              <p class="form__attention">Дальше будет ещё информация</p>

              <p class="form__description">
                Здесь мы рассмотрели функции-стрелки как способ писать меньше
                букв. Но это далеко не всё!
              </p>

              <p class="form__description">
                Стрелочные функции обладают другими интересными особенностями.
                Их изучение требует знания некоторых других возможностей языка
                JavaScript, поэтому мы вернёмся к стрелочным функциям позже, в
                главе

                <a
                  target="_blank"
                  rel="noopener"
                  href="https://learn.javascript.ru/arrow-functions"
                  class="form__link"
                >
                  Повторяем стрелочные функции.</a
                >
              </p>

              <p class="form__description">
                А пока мы можем использовать их для простых однострочных
                действий и колбэков.
              </p>

              <p class="form__subheading">
                <a
                  target="_blank"
                  rel="noopener"
                  href="https://learn.javascript.ru/arrow-functions-basics#itogo"
                  class="form__link"
                >
                  Итого</a
                >
              </p>

              <p class="form__description">
                Функции-стрелки очень удобны для однострочных действий. Они
                бывают двух типов:
              </p>

              <p class="form__subdescription">
                1. Без фигурных скобок: (...args) => expression – правая сторона
                выражение: функция выполняет его и возвращает результат.
              </p>

              <p class="form__subdescription">
                2. С фигурными скобками: (...args) => { body } – скобки
                позволяют нам писать многострочные инструкции внутри функции, но
                при этом необходимо указывать директиву return, чтобы вернуть
                какое-либо значение.
              </p>
            </div>
          </div>
          <p class="form__subheading">
            <a
              target="_blank"
              rel="noopener"
              href="https://learn.javascript.ru/arrow-functions-basics#tasks"
              class="form__link-tasks"
            >
              Задачи "Функции-стрелки, основы"</a
            >
          </p>
        </section>
        <!-- Функции-стрелки, основы -->

        <!-- encoding -->
        <div>
          <div class="encoding">
            <p class="encoding__prompt">HTML посмотреть код</p>
            <pre class="encoding__code-box">
                        <code class="encoding__code-font">                                   
                           xxx                                    
                        </code>
                     </pre>
          </div>

          <div class="encoding">
            <p class="encoding__prompt encoding__prompt_second">
              SCSS посмотреть код
            </p>
            <pre class="encoding__code-box">
                        <code>                                   
                           xxx                                    
                        </code>
                     </pre>
          </div>
        </div>
        <!-- encoding -->
      </article>

      <!-- menu-mobile -->
      <div class="menu-mobile">
        <img
          src="../../assets/logotype/smallLogo.svg"
          class="menu-mobile__logo-small"
        />
        <div class="menu-mobile__dots">
          <div class="menu-mobile__dots_item"></div>
          <div class="menu-mobile__dots_item"></div>
          <div class="menu-mobile__dots_item"></div>
        </div>
      </div>
      <!-- menu-mobile -->
    </main>
    <!-- main -->

    <!-- menu -->
    <nav class="menu">
      <!-- transform-list -->
      <ul class="menu__list">
        <a class="menu__link" href="../templates/transformations.html">
          Двумерные трансформации</a
        >
        <div class="menu__content">
          <li class="menu__item">
            <a
              class="menu__item_link"
              href="../templates/transformations.html#transformations"
              >Трансформация элемента</a
            >
          </li>
          <li class="menu__item">
            <a
              class="menu__item_link"
              href="../templates/transformations.html#translate-x"
              >Сдвиг по горизонтали</a
            >
          </li>
          <li class="menu__item">
            <a
              class="menu__item_link"
              href="../templates/transformations.html#translate-y"
              >Сдвиг по вертикали</a
            >
          </li>
          <li class="menu__item">
            <a
              class="menu__item_link"
              href="../templates/transformations.html#translate"
              >Сдвиг по горизонтали и вертикали</a
            >
          </li>
          <li class="menu__item">
            <a
              class="menu__item_link"
              href="../templates/transformations.html#scale"
              >Изменение масштаба элемента</a
            >
          </li>
          <li class="menu__item">
            <a
              class="menu__item_link"
              href="../templates/transformations.html#scale-x"
              >Изменение масштаба по горизонтали</a
            >
          </li>
          <li class="menu__item">
            <a
              class="menu__item_link"
              href="../templates/transformations.html#scale-y"
              >Изменение масштаба по вертикали</a
            >
          </li>
          <li class="menu__item">
            <a
              class="menu__item_link"
              href="../templates/transformations.html#rotate"
              >Поворот элемента</a
            >
          </li>
          <li class="menu__item">
            <a
              class="menu__item_link"
              href="../templates/transformations.html#skew-x"
              >Наклон элемента по горизонтали</a
            >
          </li>
          <li class="menu__item">
            <a
              class="menu__item_link"
              href="../templates/transformations.html#skew-y"
              >Наклон элемента по вертикали</a
            >
          </li>
          <li class="menu__item">
            <a
              class="menu__item_link"
              href="../templates/transformations.html#transform-origin"
              >Координаты трансформации элемента.</a
            >
          </li>
        </div>
      </ul>
      <!-- transform-list -->

      <!-- transitions_list -->
      <ul class="menu__list">
        <a class="menu__link" href="../templates/transitions.html">
          Плавные переходы
        </a>
        <div class="menu__content">
          <li class="menu__item">
            <a
              class="menu__item_link"
              href="../templates/transitions.html#transition"
              >Универсальное свойство</a
            >
          </li>
          <li class="menu__item">
            <a
              class="menu__item_link"
              href="../templates/transitions.html#transition-duration"
              >Длительность перехода</a
            >
          </li>
          <li class="menu__item">
            <a
              class="menu__item_link"
              href="../templates/transitions.html#transition-property"
              >Какие свойства плавно изменять</a
            >
          </li>
          <li class="menu__item">
            <a
              class="menu__item_link"
              href="../templates/transitions.html#transition-delay"
              >Задержка перехода
            </a>
          </li>
          <li class="menu__item">
            <a
              class="menu__item_link"
              href="../templates/transitions.html#transition-timing-function"
              >Скорость и ускорение переходов
            </a>
          </li>
          <li class="menu__item">
            <a
              class="menu__item_link"
              href="../templates/transitions.html#example"
              >примеры timing-function переходов</a
            >
          </li>
          <li class="menu__item">
            <a
              class="menu__item_link"
              href="../templates/transitions.html#graphics-transition"
              >Графики переходов</a
            >
          </li>
        </div>
      </ul>
      <!-- transitions_list -->

      <!-- gradient_list -->
      <ul class="menu__list">
        <a class="menu__link" href="../templates/linearGradient.html">
          Линейный градиент</a
        >
        <div class="menu__content">
          <li class="menu__item">
            <a
              class="menu__item_link"
              href="../templates/linearGradient.html#linear-gradient"
              >Линейный градиент</a
            >
          </li>
          <li class="menu__item">
            <a
              class="menu__item_link"
              href="../templates/linearGradient.html#examples"
              >Примеры прямых и диогональных переходов</a
            >
          </li>
          <li class="menu__item">
            <a
              class="menu__item_link"
              href="../templates/linearGradient.html#angled-gradients"
              >Градиенты под углом</a
            >
          </li>
          <li class="menu__item">
            <a
              class="menu__item_link"
              href="../templates/linearGradient.html#sample-flower"
              >Градиенты под углом, пример:</a
            >
          </li>
          <li class="menu__item">
            <a
              class="menu__item_link"
              href="../templates/linearGradient.html#sample"
              >Множество градиентов</a
            >
          </li>
          <li class="menu__item">
            <a
              class="menu__item_link"
              href="../templates/linearGradient.html#color-stop"
            >
              Пропорции цветов и колорстопы</a
            >
          </li>
          <li class="menu__item">
            <a
              class="menu__item_link"
              href="../templates/linearGradient.html#color-stop-sample"
              >Примеры колор стопов</a
            >
          </li>
          <li class="menu__item">
            <a
              class="menu__item_link"
              href="../templates/linearGradient.html#repeating-gradient"
            >
              Повторяющийся линейный градиент</a
            >
          </li>
          <li class="menu__item">
            <a
              class="menu__item_link"
              href="../templates/linearGradient.html#stylish-buttons"
              >Стильные кнопки</a
            >
          </li>
          <li class="menu__item">
            <a
              class="menu__item_link"
              href="../templates/linearGradient.html#footer"
              >Рекомендации</a
            >
          </li>
        </div>
      </ul>
      <!-- gradient_list -->

      <!-- stuff_list -->
      <ul class="menu__list">
        <a class="menu__link" href="../templates/coolStuff.html">Крутые вещи</a>

        <div class="menu__content">
          <li class="menu__item">
            <a
              class="menu__item_link"
              href="../templates/coolStuff.html#custom-shadows"
              >Нестандартные тени</a
            >
          </li>
          <li class="menu__item">
            <a
              class="menu__item_link"
              href="../templates/coolStuff.html#hover-active"
            >
              Эффекты при наведении на кнопки</a
            >
          </li>
          <li class="menu__item">
            <a
              class="menu__item_link"
              href="../templates/coolStuff.html#active-gallery"
            >
              Эффекты при наведении на галерею</a
            >
          </li>
          <li class="menu__item">
            <a
              class="menu__item_link"
              href="../templates/coolStuff.html#stack-cards"
              >Стопка" карт</a
            >
          </li>
        </div>
      </ul>
      <!-- stuff_list -->

      <!-- forms_list -->
      <ul class="menu__list">
        <a class="menu__link" href="../templates/forms.html"> Формы form </a>
        <div class="menu__content">
          <li class="menu__item">
            <a class="menu__item_link" href="../templates/forms.html#inputs">
              Ввод "input"</a
            >
          </li>

          <li class="menu__item">
            <a class="menu__item_link" href="../templates/forms.html#type-text">
              Поля inputs
            </a>
          </li>

          <li class="menu__item">
            <a class="menu__item_link" href="../templates/forms.html#button"
              >Кнопки button
            </a>
          </li>

          <li class="menu__item">
            <a class="menu__item_link" href="../templates/forms.html#checkbox">
              checkbox</a
            >
          </li>

          <li class="menu__item">
            <a class="menu__item_link" href="../templates/forms.html#slider"
              >Ползунки slider</a
            >
          </li>

          <li class="menu__item">
            <a
              class="menu__item_link"
              href="../templates/forms.html#radiobutton"
              >Переключатели radiobutton</a
            >
          </li>

          <li class="menu__item">
            <a
              class="menu__item_link"
              href="../templates/forms.html#multicolor-switch"
              >multicolor-switch Тройной переключатель
            </a>
          </li>

          <li class="menu__item">
            <a
              class="menu__item_link"
              href="../templates/forms.html#triple-switch"
              >triple-switch Тройной переключатель</a
            >
          </li>

          <li class="menu__item">
            <a
              class="menu__item_link"
              href="../templates/forms.html#secondary-radio"
              >secondary-radio Двойной переключатель</a
            >
          </li>

          <li class="menu__item">
            <a
              class="menu__item_link"
              href="../templates/forms.html#twin-switch "
              >twin-switch Универсальный переключатель</a
            >
          </li>

          <li class="menu__item">
            <a class="menu__item_link" href="../templates/forms.html#drop-down">
              Выпадающий или раскрывающийся список</a
            >
          </li>

          <li class="menu__item">
            <a class="menu__item_link" href="../templates/forms.html#teg-select"
              >Тег select, поле выбора
            </a>
          </li>
        </div>
      </ul>
      <!-- forms_list -->

      <!-- position-ratio_list -->
      <ul class="menu__list">
        <a class="menu__link" href="../templates/positionAspectRatio.html">
          Работа с изображениями</a
        >

        <div class="menu__content">
          <li class="menu__item">
            <a
              class="menu__item_link"
              href="../templates/positionAspectRatio.html#centering"
            >
              Центрирование centering</a
            >
          </li>

          <li class="menu__item">
            <a
              class="menu__item_link"
              href="../templates/positionAspectRatio.html#aspect-ratio"
            >
              Свойство CSS aspect-ratio: X / Y
            </a>
          </li>

          <li class="menu__item">
            <a
              class="menu__item_link"
              href="../templates/positionAspectRatio.html#factoring-width"
            >
              Факторинг в min-*и max-*</a
            >
          </li>

          <li class="menu__item">
            <a
              class="menu__item_link"
              href="../templates/positionAspectRatio.html#aspect-ratio-example"
            >
              Примеры работы свойства aspect-ratio:</a
            >
          </li>

          <li class="menu__item">
            <a
              class="menu__item_link"
              href="../templates/positionAspectRatio.html#position"
            >
              Позиционирование элемента</a
            >
          </li>

          <li class="menu__item">
            <a
              class="menu__item_link"
              href="../templates/positionAspectRatio.html#position__absolute"
            >
              Позиционирование absolute подробнее.</a
            >
          </li>

          <li class="menu__item">
            <a
              class="menu__item_link"
              href="../templates/positionAspectRatio.html#height-absolute"
            >
              Высота для position: absolute;</a
            >
          </li>

          <li class="menu__item">
            <a
              class="menu__item_link"
              href="../templates/positionAspectRatio.html#relative-absolute"
            >
              Позиционирование и aspect-ratio: X / Y;</a
            >
          </li>
        </div>
      </ul>
      <!-- position-ratio_list -->

      <!-- utility_list -->
      <ul class="menu__list">
        <a class="menu__link" href="../templates/utility.html">
          Полезная информация</a
        >

        <div class="menu__content">
          <li class="menu__item">
            <a class="menu__item_link" href="../templates/utility.html#my-tabs">
              Мои вкладки</a
            >
          </li>

          <li class="menu__item">
            <a
              class="menu__item_link"
              href="../templates/utility.html#html5book.ru"
            >
              HTML5BOOK.ru теория html, css, js</a
            >
          </li>

          <li class="menu__item">
            <a
              class="menu__item_link"
              href="../templates/utility.html#HTML5CSS.ru"
            >
              HTML5CSS.ru Как сделать?</a
            >
          </li>

          <li class="menu__item">
            <a
              class="menu__item_link"
              href="../templates/utility.html#WebReference"
            >
              Мощный учебник WebReference</a
            >
          </li>

          <li class="menu__item">
            <a
              class="menu__item_link"
              href="../templates/utility.html#css-tricks "
            >
              Учебник css-tricks и Aspect Ratio
            </a>
          </li>

          <li class="menu__item">
            <a class="menu__item_link" href="../templates/utility.html#Git">
              Ресурсы для изучения Git</a
            >
          </li>

          <li class="menu__item">
            <a class="menu__item_link" href="../templates/utility.html#ru.bem">
              Методология БЭМ
            </a>
          </li>

          <li class="menu__item">
            <a
              class="menu__item_link"
              href="../templates/utility.html#first-child"
            >
              Структурные псевдоклассы</a
            >
          </li>

          <li class="menu__item">
            <a class="menu__item_link" href="../templates/utility.html#after">
              ::after и ::before</a
            >
          </li>

          <li class="menu__item">
            <a
              class="menu__item_link"
              href="../templates/utility.html#form__link"
            >
              Как сделать гиперссылки на сайте</a
            >
          </li>

          <li class="menu__item">
            <a
              class="menu__item_link"
              href="../templates/utility.html#svoystva-teksta"
            >
              Свойства шрифта, текста</a
            >
          </li>

          <li class="menu__item">
            <a
              class="menu__item_link"
              href="../templates/utility.html#Select-Option"
            >
              Стилизация Select-Option</a
            >
          </li>

          <li class="menu__item">
            <a
              class="menu__item_link"
              href="../templates/utility.html#user-select"
            >
              user-select</a
            >
          </li>

          <li class="menu__item">
            <a
              class="menu__item_link"
              href="../templates/utility.html#webfanat"
            >
              Блог веб разработки webfanat</a
            >
          </li>

          <li class="menu__item">
            <a class="menu__item_link" href="../templates/utility.html#">
              xxx</a
            >
          </li>

          <li class="menu__item">
            <a class="menu__item_link" href="../templates/utility.html#">
              xxx</a
            >
          </li>

          <li class="menu__item">
            <a class="menu__item_link" href="../templates/utility.html#">
              xxx</a
            >
          </li>
        </div>
      </ul>
      <!-- utility_list -->

      <!-- shadow_list -->
      <ul class="menu__list">
        <a class="menu__link" href="../templates/boxShadow.html">
          Тени box-shadow
        </a>
        <div class="menu__content">
          <li class="menu__item">
            <a
              class="menu__item_link"
              href="../templates/boxShadow.html#box-shadow"
            >
              Тени box-shadow</a
            >
          </li>
        </div>
      </ul>
      <!-- shadow_list -->

      <!-- javaScriptBasics Основы JavaScript-->
      <ul class="menu__list">
        <a class="menu__link" href="../templates/javaScriptBasics.html">
          Основы JavaScript
        </a>
        <div class="menu__content">
          <li class="menu__item">
            <a
              class="menu__item_link"
              href="../templates/javaScriptBasics.html#teg-script"
            >
              Подключение JavaScript, тег: &lt;script&gt;</a
            >
          </li>

          <li class="menu__item">
            <a
              class="menu__item_link"
              href="../templates/javaScriptBasics.html#peremennay"
            >
              Переменная</a
            >
          </li>

          <li class="menu__item">
            <a
              class="menu__item_link"
              href="../templates/javaScriptBasics.html#tip-dannih"
            >
              Типы данных</a
            >
          </li>

          <li class="menu__item">
            <a
              class="menu__item_link"
              href="../templates/javaScriptBasics.html#alert-prompt-confirm"
            >
              Взаимодействие: alert, prompt, confirm</a
            >
          </li>

          <li class="menu__item">
            <a
              class="menu__item_link"
              href="../templates/javaScriptBasics.html#preobrazovanie-tipov"
            >
              Преобразование типов</a
            >
          </li>

          <li class="menu__item">
            <a
              class="menu__item_link"
              href="../templates/javaScriptBasics.html#operatori-bazic"
            >
              Базовые операторы, математика</a
            >
          </li>

          <li class="menu__item">
            <a
              class="menu__item_link"
              href="../templates/javaScriptBasics.html#operatori-sravneniy"
            >
              Операторы сравнения</a
            >
          </li>

          <li class="menu__item">
            <a
              class="menu__item_link"
              href="../templates/javaScriptBasics.html#uslovnoe-vetvlenie-if-?"
            >
              Условное ветвление: if, '?'</a
            >
          </li>

          <li class="menu__item">
            <a
              class="menu__item_link"
              href="../templates/javaScriptBasics.html#logical-operators"
            >
              Логические операторы</a
            >
          </li>

          <li class="menu__item">
            <a
              class="menu__item_link"
              href="../templates/javaScriptBasics.html#tsikl-while-for"
            >
              Циклы while и for</a
            >
          </li>

          <li class="menu__item">
            <a
              class="menu__item_link"
              href="../templates/javaScriptBasics.html#switch"
            >
              Конструкция "switch"</a
            >
          </li>

          <li class="menu__item">
            <a
              class="menu__item_link"
              href="../templates/javaScriptBasics.html#function"
            >
              Функции</a
            >
          </li>

          <li class="menu__item">
            <a
              class="menu__item_link"
              href="../templates/javaScriptBasics.html#Function-Expression-call-back"
            >
              Функции Expression и «call back»</a
            >
          </li>

          <li class="menu__item">
            <a
              class="menu__item_link"
              href="../templates/javaScriptBasics.html#strelochnye-funktsii"
            >
              Функции-стрелки, основы
            </a>
          </li>
        </div>
      </ul>
      <!-- javaScriptBasics Основы JavaScript-->
    </nav>
    <!-- menu -->

    <!-- header  -->
    <header class="header"></header>
    <!-- header  -->
  </body>
</html>
